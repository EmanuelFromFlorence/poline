{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["export type FuncNumberReturn = (arg0: number) => Vector2;\nexport type Vector2 = [number, number];\nexport type Vector3 = [number, ...Vector2];\nexport type PartialVector3 = [number | null, number | null, number | null];\n\n/**\n * Converts the given (x, y, z) coordinate to an HSL color\n * The (x, y) values are used to calculate the hue, while the z value is used as the saturation\n * The lightness value is calculated based on the distance of (x, y) from the center (0.5, 0.5)\n * Returns an array [hue, saturation, lightness]\n * @param xyz:Vector3 [x, y, z] coordinate array in (x, y, z) format (0-1, 0-1, 0-1)\n * @returns [hue, saturation, lightness]: Vector3 color array in HSL format (0-360, 0-1, 0-1)\n * @example\n * pointToHSL(0.5, 0.5, 1) // [0, 1, 0.5]\n * pointToHSL(0.5, 0.5, 0) // [0, 1, 0]\n * pointToHSL(0.5, 0.5, 1) // [0, 1, 1]\n **/\n\nexport const pointToHSL = (xyz: Vector3): Vector3 => {\n  const [x, y, z] = xyz;\n\n  // cy and cx are the center (y and x) values\n  const cx = 0.5;\n  const cy = 0.5;\n\n  // Calculate the angle between the point (x, y) and the center (cx, cy)\n  const radians = Math.atan2(y - cy, x - cx);\n\n  // Convert the angle to degrees and shift it so that it goes from 0 to 360\n  let deg = radians * (180 / Math.PI);\n  deg = (360 + deg) % 360;\n\n  // The saturation value is taken from the z coordinate\n  const s = z;\n\n  // Calculate the lightness value based on the distance from the center\n  const dist = Math.sqrt(Math.pow(y - cy, 2) + Math.pow(x - cx, 2));\n  const l = dist / cx;\n\n  // Return the HSL color as an array [hue, saturation, lightness]\n  return [deg, s, l];\n};\n\n/**\n * Converts the given HSL color to an (x, y, z) coordinate\n * The hue value is used to calculate the (x, y) position, while the saturation value is used as the z coordinate\n * The lightness value is used to calculate the distance from the center (0.5, 0.5)\n * Returns an array [x, y, z]\n * @param hsl:Vector3 [hue, saturation, lightness] color array in HSL format (0-360, 0-1, 0-1)\n * @returns [x, y, z]:Vector3 coordinate array in (x, y, z) format (0-1, 0-1, 0-1)\n * @example\n * hslToPoint([0, 1, 0.5]) // [0.5, 0.5, 1]\n * hslToPoint([0, 1, 0]) // [0.5, 0.5, 1]\n * hslToPoint([0, 1, 1]) // [0.5, 0.5, 1]\n * hslToPoint([0, 0, 0.5]) // [0.5, 0.5, 0]\n **/\nexport const hslToPoint = (hsl: Vector3): Vector3 => {\n  // Destructure the input array into separate hue, saturation, and lightness values\n  const [h, s, l] = hsl;\n  // cx and cy are the center (x and y) values\n  const cx = 0.5;\n  const cy = 0.5;\n  // Calculate the angle in radians based on the hue value\n  const radians = h / (180 / Math.PI);\n  // Calculate the distance from the center based on the lightness value\n  const dist = l * cx;\n  // Calculate the x and y coordinates based on the distance and angle\n  const x = cx + dist * Math.cos(radians);\n  const y = cy + dist * Math.sin(radians);\n  // The z coordinate is equal to the saturation value\n  const z = s;\n  // Return the (x, y, z) coordinate as an array [x, y, z]\n  return [x, y, z];\n};\n\nexport const randomHSLPair = (\n  startHue: number = Math.random() * 360,\n  saturations: Vector2 = [Math.random(), Math.random()],\n  lightnesses: Vector2 = [0.75 + Math.random() * 0.2, 0.3 + Math.random() * 0.2]\n): [Vector3, Vector3] => [\n  [startHue, saturations[0], lightnesses[0]],\n  [(startHue + 60 + Math.random() * 180) % 360, saturations[1], lightnesses[1]],\n];\n\nexport const randomHSLTriple = (\n  startHue: number = Math.random() * 360,\n  saturations: Vector3 = [Math.random(), Math.random(), Math.random()],\n  lightnesses: Vector3 = [\n    0.75 + Math.random() * 0.2,\n    Math.random() * 0.2,\n    0.75 + Math.random() * 0.2,\n  ]\n): [Vector3, Vector3, Vector3] => [\n  [startHue, saturations[0], lightnesses[0]],\n  [(startHue + 60 + Math.random() * 180) % 360, saturations[1], lightnesses[1]],\n  [(startHue + 60 + Math.random() * 180) % 360, saturations[2], lightnesses[2]],\n];\n\nexport const vectorsOnLine = (\n  p1: Vector3,\n  p2: Vector3,\n  numPoints = 4,\n  invert = false,\n  fx = (t: number, invert: boolean): number => (invert ? 1 - t : t),\n  fy = (t: number, invert: boolean): number => (invert ? 1 - t : t),\n  fz = (t: number, invert: boolean): number => (invert ? 1 - t : t)\n): Vector3[] => {\n  const points: Vector3[] = [];\n\n  for (let i = 0; i < numPoints; i++) {\n    const t = i / (numPoints - 1);\n    const tModifiedX = fx(t, invert);\n    const tModifiedY = fy(t, invert);\n    const tModifiedZ = fz(t, invert);\n    const x = (1 - tModifiedX) * p1[0] + tModifiedX * p2[0];\n    const y = (1 - tModifiedY) * p1[1] + tModifiedY * p2[1];\n    const z = (1 - tModifiedZ) * p1[2] + tModifiedZ * p2[2];\n\n    points.push([x, y, z]);\n  }\n\n  return points;\n};\n\nexport type PositionFunction = (t: number, reverse?: boolean) => number;\n\nconst linearPosition: PositionFunction = (t: number) => {\n  return t;\n};\n\nconst exponentialPosition: PositionFunction = (t: number, reverse = false) => {\n  if (reverse) {\n    return 1 - (1 - t) ** 2;\n  }\n  return t ** 2;\n};\n\nconst quadraticPosition: PositionFunction = (t: number, reverse = false) => {\n  if (reverse) {\n    return 1 - (1 - t) ** 3;\n  }\n  return t ** 3;\n};\n\nconst cubicPosition: PositionFunction = (t: number, reverse = false) => {\n  if (reverse) {\n    return 1 - (1 - t) ** 4;\n  }\n  return t ** 4;\n};\n\nconst quarticPosition: PositionFunction = (t: number, reverse = false) => {\n  if (reverse) {\n    return 1 - (1 - t) ** 5;\n  }\n  return t ** 5;\n};\n\nconst sinusoidalPosition: PositionFunction = (t: number, reverse = false) => {\n  if (reverse) {\n    return 1 - Math.sin(((1 - t) * Math.PI) / 2);\n  }\n  return Math.sin((t * Math.PI) / 2);\n};\n\nconst asinusoidalPosition: PositionFunction = (t: number, reverse = false) => {\n  if (reverse) {\n    return 1 - Math.asin(1 - t) / (Math.PI / 2);\n  }\n  return Math.asin(t) / (Math.PI / 2);\n};\n\nconst buggyCosinePosition: PositionFunction = (t: number, reverse = false) => {\n  if (reverse) {\n    return 1 - Math.cos(((1 - t) * Math.PI) / 2);\n  }\n  return Math.cos((t * Math.PI) / 2);\n};\n\n// Math.sqrt(1 - (1 - t) ** 2)\n// Math,atan2(Math.sqrt(1 - t ** 2), t)\n\nconst circularPosition: PositionFunction = (t: number, reverse = false) => {\n  if (reverse) {\n    return 1 - Math.sqrt(1 - (1 - t) ** 2);\n  }\n  return 1 - Math.sqrt(1 - t ** 2);\n};\n\nconst arcPosition: PositionFunction = (t: number, reverse = false) => {\n  if (reverse) {\n    return Math.sqrt(1 - (1 - t) ** 2);\n  }\n  return 1 - Math.sqrt(1 - t);\n};\n\nexport const positionFunctions = {\n  linearPosition,\n  exponentialPosition,\n  quadraticPosition,\n  cubicPosition,\n  quarticPosition,\n  sinusoidalPosition,\n  asinusoidalPosition,\n  buggyCosinePosition,\n  circularPosition,\n  arcPosition,\n};\n\n/**\n * Calculates the distance between two points\n * @param p1 The first point\n * @param p2 The second point\n * @returns The distance between the two points\n * @example\n * const p1 = [0, 0, 0];\n * const p2 = [1, 1, 1];\n * const dist = distance(p1, p2);\n * console.log(dist); // 1.7320508075688772\n **/\nconst distance = (p1: PartialVector3, p2: PartialVector3): number => {\n  const a = p1[0] === null || p2[0] === null ? 0 : p2[0] - p1[0];\n  const b = p1[1] === null || p2[1] === null ? 0 : p2[1] - p1[1];\n  const c = p1[2] === null || p2[2] === null ? 0 : p2[2] - p1[2];\n\n  return Math.sqrt(a * a + b * b + c * c);\n};\n\ntype ColorPointCollection = {\n  x?: number;\n  y?: number;\n  z?: number;\n  color?: Vector3;\n  insertAtIndex?: number;\n};\n\nclass ColorPoint {\n  public x = 0;\n  public y = 0;\n  public z = 0;\n  public color: Vector3 = [0, 0, 0];\n\n  constructor({ x, y, z, color }: ColorPointCollection = {}) {\n    this.positionOrColor({ x, y, z, color });\n  }\n\n  positionOrColor({ x, y, z, color }: ColorPointCollection) {\n    if (x && y && y && color) {\n      throw new Error(\"Point must be initialized with either x,y,z or hsl\");\n    } else if (x && y && z) {\n      this.x = x;\n      this.y = y;\n      this.z = z;\n      this.color = pointToHSL([this.x, this.y, this.z]);\n    } else if (color) {\n      this.color = color;\n      [this.x, this.y, this.z] = hslToPoint(color);\n    }\n  }\n\n  set position([x, y, z]: Vector3) {\n    this.x = x;\n    this.y = y;\n    this.z = z;\n    this.color = pointToHSL([this.x, this.y, this.z]);\n  }\n\n  get position(): Vector3 {\n    return [this.x, this.y, this.z];\n  }\n\n  set hsl([h, s, l]: Vector3) {\n    this.color = [h, s, l];\n    [this.x, this.y, this.z] = hslToPoint(this.color);\n  }\n\n  get hsl(): Vector3 {\n    return this.color;\n  }\n\n  shiftHue(angle: number): void {\n    this.color[0] = (360 + (this.color[0] + angle)) % 360;\n\n    [this.x, this.y, this.z] = hslToPoint(this.color);\n  }\n\n  get hslCSS(): string {\n    return `hsl(${this.color[0]}, ${this.color[1] * 100}%, ${\n      this.color[2] * 100\n    }%)`;\n  }\n}\n\nexport type AnchorPointReference = {\n  pointReference?: ColorPoint;\n  pointIndex?: number;\n} & ColorPointCollection;\n\nexport type PolineOptions = {\n  anchorColors: Vector3[];\n  numPoints: number;\n  positionFunction?: (t: number, invert?: boolean) => number;\n  positionFunctionX?: (t: number, invert?: boolean) => number;\n  positionFunctionY?: (t: number, invert?: boolean) => number;\n  positionFunctionZ?: (t: number, invert?: boolean) => number;\n  closedLoop: boolean;\n};\n\nexport class Poline {\n  private _needsUpdate = true;\n  public anchorPoints: ColorPoint[];\n\n  private _numPoints: number;\n  private points: ColorPoint[][];\n\n  private _positionFunctionX = sinusoidalPosition;\n  private _positionFunctionY = sinusoidalPosition;\n  private _positionFunctionZ = sinusoidalPosition;\n\n  private connectLastAndFirstAnchor = false;\n\n  private _animationFrame: null | number = null;\n\n  constructor(\n    {\n      anchorColors = randomHSLPair(),\n      numPoints = 4,\n      positionFunction = sinusoidalPosition,\n      positionFunctionX,\n      positionFunctionY,\n      positionFunctionZ,\n      closedLoop,\n    }: PolineOptions = {\n      anchorColors: randomHSLPair(),\n      numPoints: 4,\n      positionFunction: sinusoidalPosition,\n      closedLoop: false,\n    }\n  ) {\n    if (!anchorColors || anchorColors.length < 2) {\n      throw new Error(\"Must have at least two anchor colors\");\n    }\n\n    this.anchorPoints = anchorColors.map(\n      (point) => new ColorPoint({ color: point })\n    );\n\n    this._numPoints = numPoints + 2; // add two for the anchor points\n\n    this.positionFunctionX =\n      positionFunctionX || positionFunction || sinusoidalPosition;\n    this.positionFunctionY =\n      positionFunctionY || positionFunction || sinusoidalPosition;\n    this.positionFunctionZ =\n      positionFunctionZ || positionFunction || sinusoidalPosition;\n\n    this.connectLastAndFirstAnchor = closedLoop;\n\n    this.updatePointPairs();\n  }\n\n  get numPoints(): number {\n    return this._numPoints;\n  }\n\n  set numPoints(numPoints: number) {\n    if (numPoints < 1) {\n      throw new Error(\"Must have at least one point\");\n    }\n    this._numPoints = numPoints + 2; // add two for the anchor points\n    this.updatePointPairs();\n  }\n\n  set positionFunctionX(positionFunctionX: PositionFunction) {\n    this._positionFunctionX = positionFunctionX;\n    this.updatePointPairs();\n  }\n\n  get positionFunctionX(): PositionFunction {\n    return this._positionFunctionX;\n  }\n\n  set positionFunctionY(positionFunctionY: PositionFunction) {\n    this._positionFunctionY = positionFunctionY;\n    this.updatePointPairs();\n  }\n\n  get positionFunctionY(): PositionFunction {\n    return this._positionFunctionY;\n  }\n\n  set positionFunctionZ(positionFunctionZ: PositionFunction) {\n    this._positionFunctionZ = positionFunctionZ;\n    this.updatePointPairs();\n  }\n\n  get positionFunctionZ(): PositionFunction {\n    return this._positionFunctionZ;\n  }\n\n  updatePointPairs(): void {\n    const pairs = [] as ColorPoint[][];\n\n    const anchorPointsLength = this.connectLastAndFirstAnchor\n      ? this.anchorPoints.length\n      : this.anchorPoints.length - 1;\n\n    for (let i = 0; i < anchorPointsLength; i++) {\n      const pair = [\n        this.anchorPoints[i],\n        this.anchorPoints[(i + 1) % this.anchorPoints.length],\n      ] as ColorPoint[];\n\n      pairs.push(pair);\n    }\n\n    this.points = pairs.map((pair, i) => {\n      const p1position = pair[0] ? pair[0].position : ([0, 0, 0] as Vector3);\n      const p2position = pair[1] ? pair[1].position : ([0, 0, 0] as Vector3);\n\n      return vectorsOnLine(\n        p1position,\n        p2position,\n        this.numPoints,\n        i % 2 ? true : false,\n        this.positionFunctionX,\n        this.positionFunctionY,\n        this.positionFunctionZ\n      ).map((p) => new ColorPoint({ x: p[0], y: p[1], z: p[2] }));\n    });\n  }\n\n  addAnchorPoint({\n    x,\n    y,\n    z,\n    color,\n    insertAtIndex,\n  }: ColorPointCollection): ColorPoint {\n    const newAnchor = new ColorPoint({ x, y, z, color });\n    if (insertAtIndex) {\n      this.anchorPoints.splice(insertAtIndex, 0, newAnchor);\n    } else {\n      this.anchorPoints.push(newAnchor);\n    }\n    this.updatePointPairs();\n    return newAnchor;\n  }\n\n  removeAnchorPoint(point: ColorPoint): void {\n    const index = this.anchorPoints.indexOf(point);\n    if (index > -1) {\n      this.anchorPoints.splice(index, 1);\n    }\n    this.updatePointPairs();\n  }\n\n  getClosestAnchorPoint(\n    point: PartialVector3,\n    maxDistance: 0.5\n  ): ColorPoint | null {\n    const distances = this.anchorPoints.map((anchor) =>\n      distance(anchor.position, point)\n    );\n\n    const minDistance = Math.min(...distances);\n\n    if (minDistance > maxDistance) {\n      return null;\n    }\n\n    const closestAnchorIndex = distances.indexOf(minDistance);\n\n    return this.anchorPoints[closestAnchorIndex] || null;\n  }\n\n  public set closedLoop(newStatus: boolean) {\n    this.connectLastAndFirstAnchor = newStatus;\n    this.updatePointPairs();\n  }\n\n  get flattenedPoints() {\n    return this.points\n      .flat()\n      .filter((p, i) => (i != 0 ? i % this.numPoints : true));\n  }\n\n  get colors() {\n    const colors = this.flattenedPoints.map((p) => p.color);\n    if (this.connectLastAndFirstAnchor) {\n      colors.pop();\n    }\n    return colors;\n  }\n\n  get colorsCSS() {\n    const cssColors = this.flattenedPoints.map((p) => p.hslCSS);\n    if (this.connectLastAndFirstAnchor) {\n      cssColors.pop();\n    }\n    return cssColors;\n  }\n\n  shiftHue(hShift: number): void {\n    this.anchorPoints.forEach((p) => p.shiftHue(hShift));\n    this.updatePointPairs();\n  }\n}\n"],
  "mappings": "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",
  "names": ["invert"]
}
