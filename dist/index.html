<!DOCTYPE html>

<html lang="en">

<head>
  <meta charset="utf-8" />
  <!-- Primary Meta Tags -->
  <title>Poline — esoteric color palette generator</title>
  <meta name="title" content="Poline —  esoteric color palette generator">
  <meta name="description"
    content="poline is lightweight, dependency free and fast JavaScript function written in TypeScript. It draws lines between anchors over polar coordinates to generate pleasing color palettes.">

  <!-- Open Graph / Facebook -->
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://meodai.github.io/poline/">
  <meta property="og:title" content="Poline —  esoteric color palette generator">
  <meta property="og:description"
    content="poline is lightweight, dependency free and fast JavaScript function written in TypeScript. It draws lines between anchors over polar coordinates to generate pleasing color palettes.">
  <meta property="og:image" content="https://meodai.github.io/poline/socialfb.png">

  <!-- Twitter -->
  <meta property="twitter:card" content="summary_large_image">
  <meta property="twitter:url" content="https://meodai.github.io/poline/">
  <meta property="twitter:title" content="Poline —  esoteric color palette generator">
  <meta property="twitter:description"
    content="poline is lightweight, dependency free and fast JavaScript function written in TypeScript. It draws lines between anchors over polar coordinates to generate pleasing color palettes.">
  <meta property="twitter:image" content="https://meodai.github.io/poline/socialfb.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/styles/atom-one-light.min.css">
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Aboreto&family=Work+Sans:wght@300;400&display=swap" rel="stylesheet">
  
  <style>
    :root {
      background: #fff;
      color: #202124;

      font-family: 'Work Sans', sans-serif;
      font-weight: 300;
      font-size: 0.9rem;

      font-size: calc(0.4rem + 0.5vw);
    }

    a {
      color: #202124;
    }

    a:hover {
      text-decoration: none;
    }

    h1, h2, h3, .t, .wheel__huelabel {
      font-family: 'Aboreto', cursive;
    }

    h1 {
      font-size: 5rem;
      margin: 0;
      padding: 0;
      font-weight: normal;
      letter-spacing: -0.05em;
      margin-left: -0.06em;
    }

    h2 {
      font-size: 2.5rem;
      margin: 0;
      padding: 0;
      font-weight: normal;
      letter-spacing: -0.05em;
      margin-left: -0.06em;
    }

    .t-intro {
      margin: 3em 0 1em;
    }


    p {
      line-height: 1.5;
    }

    .poline-picker {
      position: absolute;
      width: min(60vmin, 60%);
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }

    .poline-picker__circprev {
      width: 12vmin;
      height: 12vmin;
      background: conic-gradient(var(--prev));
      border-radius: 50%;
      position: absolute;
      top: 100%;
      left: 50%;
      z-index: 3;
      transition: transform 0.5s cubic-bezier(0.3, 0.7, 0, 1);
      box-shadow: 0 0 0 0.7vmin #fff;
      pointer-events: none;
      transform: translate(-50%, -50%) scale(0.4);
    }

    .picker {
      position: relative;
      width: 100%;
      aspect-ratio: 1;
      --s: .4;
      --l: .5;
      border-radius: 50%;
      background: radial-gradient(closest-side, #000, rgba(255, 255, 255, 0), #fff), conic-gradient(from 90deg, var(--grad));
    }

    svg {
      position: relative;
      z-index: 2;
      overflow: visible !important;
      width: 100%;
    
    }

    svg line.wheel__line {
      stroke: #202124;
      stroke-width: 0.25;
      stroke-dasharray: 0.5 0.5;
      pointer-events: none;
    }

    svg circle {
      stroke: #000;
      stroke-width: 0.25;
    }

    svg .wheel__point {
      pointer-events: none;
    }

    svg .wheel__anchor {
      pointer-events: all;
      cursor: grab;
    }

    svg line.wheel__satline {
      stroke-dasharray: 0 0;
      stroke-width: 1;
      stroke-linecap: round;
    }

    svg line.wheel__satline--bg {
      stroke: #fff;
      stroke-width: 1.5;
      stroke-dasharray: 0 0;
    }

    .wheel__huelabel {
      user-select: none;
      pointer-events: none;
      font-weight: normal;
      box-sizing: border-box;
      position: absolute;
      top: 50%;
      left: 50%;
      width: calc(100% + 16vmin);
      transform: translate(-50%, -50%) rotate(calc(var(--i, 0) * 360deg));
      font-size: 1.7vmin;
      padding: 0.2em 3em 0.2em 120.5%;
      z-index: 1;
      text-align: right;
      pointer-events: none;
      transition: font-size 0.3s cubic-bezier(.3,.7,0,1);
    }

    .picker:hover .wheel__huelabel {
      font-size: 1vmin;
    }

    .picker:hover .wheel__huelabel--active {
      font-size: 1.7vmin;
    }

    .wheel__huelabel::before,
    .wheel__huelabel::after {
      content: "";
      position: absolute;
      bottom: 50%;
      left: 91%;
      right: 6vmin;
      height: 1px;
      background: #202124;
      transform: translateY(50%);
    }

    .wheel__huelabel::after {
      height: 30%;
      aspect-ratio: 1;
      right: auto;
      left: 90%;
      background: hsl(calc(360 * var(--i, 0)), 100%, 70%);
      border-radius: 50%;
      border: 1px solid #fff;
      transform: translate(-50%, 50%) scale(1);
      transition: transform 0.2s ease-in-out;
    }

    .wheel__huelabel--active::after {
      transform: translate(-50%, 50%) scale(1.2);
    }

    label {
      display: block;
      margin: 1rem 0;
      font-size: .8rem;
    }
    label .t {
      display: block;
      margin: 0;
      font-size: 1.25rem;
    }
    select {
      margin-top: 1em;
      display: block;
      padding: 0;
      border: none;
      font: inherit;
      font-family: inherit;

      font-size: 1rem;
      text-decoration: underline;
    }
    .controls {
    }

    button {
      font-family: 'Aboreto', cursive;
      background-color: #202125;
      color: #fff;
    }

    .l-wrap {
      display: flex;
    }

    .l-menu {
      flex: 0 0 40%;
      width: 40%;
      box-sizing: border-box;
      padding: 0 8rem 20vh 8rem;
    }

    .l-demo {
      position: fixed;
      width: 60%;
      height: 100%;
      right: 0;
      border-left: 1px solid #e0e0e0;
    }
    
    .drawer {
      --preview-width: 2rem;
      position: fixed;
      top: 0;
      left: 0;
      bottom: 0;
      width: 30%;
      background: #202125;
      transform: translateX(calc(-100% + var(--preview-width)));
    }

    .drawer__preview {
      position: absolute;
      right: 0;
      bottom: 0;
      top: 0;
      width: var(--preview-width);

      background: linear-gradient(0deg, var(--prev));
    }
    .drawer__preview::before,
    .drawer__preview::after {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      background: linear-gradient(0deg, var(--prev-smooth));
    }
    .drawer__preview::after {
      right: 0;
      width: 1rem;
      left: auto;
      display: none;
    }
    .drawer__preview::before {
      z-index: -1;
      transform: translateX(1rem) scaleY(1.1);
      filter: blur(15px);
      opacity: 0.5;
      right: 0;
    }
    .l-sec {
      min-height: 20vh;
      opacity: 1;
      transition: 400ms opacity linear;
    }
    .l-sec + .l-sec {
      margin-top: 10vh;
    }
    .l-sec--intro {
      padding-top: 32vh;
      display: flex;
      align-items: center;
    }
    .l-sec--intro + .l-sec {
    }
    .l-sec__inner {
      width: 100%;
    }
    .l-sec--active {
      opacity: 1; 
    }
    .l-sec__preview {
      position: relative;
      display: block;
      height: 1.75rem;
      background-image: linear-gradient(90deg, var(--prev-smooth)),
                        linear-gradient(90deg, var(--prev));
      background-size: 100% 50%;
      background-position: 0 0, 0 100%;
      background-repeat: no-repeat;
      margin: 0;
    }
    .l-sec__preview::after {
      content: '';
      position: absolute;
      left: 0;
      right: 0;
      top: calc(50% - 1px);
      height: 2px;
      background: #fff;
    }

    .l-sec__preview figcaption {
      display: none;
    }
    
    code {
      position: relative;
      display: block;
      font-size: .85rem;
      color: #000;
      background: #fff;
      padding: 1.5em 1.2em;
      border-radius: 0.2em;
      border: 1px solid #e0e0e0;
      background-color: #fff;
    }
    .code-ex {
      position: relative;
    }
    .code-ex::before {
      opacity: 1;
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(45deg, var(--prev-smooth));
      z-index: -1;
      opacity: 0;
      transform: translateX(0);
    }

    .l-sec--active .code-ex::before {
      opacity: 1;
      transform: translateX(-1em);
      transition: 200ms transform linear;
    }

    .toc {
      font-size: 1em;
      list-style-type: upper-roman;
      font-family: 'Aboreto', cursive;
      margin: 2em 0 0;
      padding: 0;
    }

    .toc a {
      font-size: 1em;
      font-family: 'Work Sans', sans-serif;
    }
    .toc li {
      margin: 0.5em 0 0;
    }
  </style>
</head>

<body>
  <main class="l-wrap">
    <section class="l-menu">
      <div class="l-sec l-sec--intro">
        <div class="l-sec__inner" data-section="intro">
          <h1>Poline</h1>
          <p class="t-intro">
            "<strong class="t">poline</strong>" is an enigmatic color palette generator, that harnesses the mystical witchcraft of polar coordinates. Its
            methodology, defying conventional color science, is steeped in the esoteric knowledge of the early 20th century. This
            magical technology defies explanation, drawing lines between anchors to produce visually striking and otherworldly
            palettes. It is an indispensable tool for the modern generative sorcerer, and a delight for the eye.
          </p>
        </div>
      </div>
      <aside class="l-sec" aria-label="Table of Contents">
        <div class="l-sec__inner">
          <p>
            This page serves as the documentation for '<strong class="t">Poline</strong>'. 
            It is divided into the following sections:
          </p>
          <ol data-toc class="toc">

          </ol>
        </div>
      </aside>
      <article class="l-sec">
        <div class="l-sec__inner" data-section="summoning">
          <h2 id="summoning">Summoning</h2>
          <p>
            When summoning a "<strong class="t">poline</strong>" without providing any arguments. 
            It will generate a palette with two random <strong>anchors</strong>. However, you can also
            provide a list of <strong>anchors</strong> to the function. The <strong>anchors</strong> are
            represented as a list of <strong>hsl</strong> values.
            <pre class="code-ex"><code class="language-js" data-code="summoning"></code></pre>
          </p>
        </div>
      </article>
      <article class="l-sec">
        <div class="l-sec__inner" data-section="points">
          <h2 id="points">Points</h2>
          <p>
            As demonstrated on the illustration, "<strong class="t">Poline</strong>"
            works by drawing lines between the <strong>anchors</strong>. The number of <strong>points</strong>
            determines the number of colors generated between each pair of anchors. 
            The more <strong>points</strong> you have, the more colors you will get.
          </p>
          <pre class="code-ex"><code class="language-js" data-code="points"></code></pre>
          <p>
            So the total amount of colors generated is <strong>points</strong> * <strong>pair of anchors</strong>. If omitted, the default value is <strong>4</strong>. 
            It can be changed after initialization by setting the <strong>numPoints</strong> property on your "<strong class="t">Poline</strong>" instance.
          </p>
          <label>
            <span class="t">Steps</span>
            <input type="range" min="1" max="15" value="4" data-steps>
          </label>
        </div>
      </article>
      <article class="l-sec">
        <div class="l-sec__inner" data-section="anchors">
          <h2 id="anchors">Anchors</h2>
          <p>
            The <strong>anchors</strong> are the points that the lines are drawn between. The <strong>anchors</strong> are
            represented as a list of <strong>hsl</strong> values. The <strong>hsl</strong> values are
            represented as an array of <strong>hue</strong>, <strong>saturation</strong> and <strong>lightness</strong>.
            The <strong>hue</strong>[0…360], the <strong>saturation</strong>[0…1] and the
            <strong>lightness</strong>[0…1].
          </p>
          <p>
            Either provide a list of <strong>anchors</strong> on initialization as in the examples above
            or let "<strong class="t">poline</strong>" generate a random palette for you. (by omitting the anchorColors argument)
          </p>
          <p>
            You can add anchors after initialization by calling the <strong>addAnchor</strong> method. 
            Either provide a list of <strong>hsl</strong> values or <strong>X,Y,Z</strong> coordinates.
          </p>
          <pre class="code-ex"><code class="language-js" data-code="anchors"></code></pre>
        </div>
      </article>
      <article class="l-sec">
        <div class="l-sec__inner" data-section="UpdatingAnchors">
          <h2 id="UpdatingAnchors">Updating Anchors</h2>
          <p>
            You can update the <strong>anchors</strong> by calling the <strong>updateAnchorPoint</strong> method.
            The method takes the <strong>anchor</strong> reference and either a color as a <strong>HSL</strong> representation
            or an <strong>XYZ</strong> position array.
          </p>
          <pre class="code-ex"><code class="language-js" data-code="UpdatingAnchors"></code></pre>
          <button data-randomize>Randomize Positions</button>
        </div>
      </article>
      <article class="l-sec">
        <div class="l-sec__inner" data-section="positionFunctions">
          <h2 id="positionFunctions">Position Functions</h2>
          <p>
            The <strong>position functions</strong> are used to determine the position of the 
            <strong>points</strong> between the <strong>anchors</strong>. The <strong>position functions</strong> 
            can be the same for XYZ (positionFunction) or different for each axis (positionFunctionX, positionFunctionY, positionFunctionZ).
          </p>
          <p>
            They function a lot like an easing function can be imported from the <strong class="t">poline</strong> module.
          </p>
          <pre class="code-ex"><code class="language-js" data-code="positionFunctions"></code></pre>
          <p>
            Any function that takes a <strong>number between 0 and 1</strong> and returns a number between 0 and 1 can be used as a <strong>position function</strong>.
            The second argument is called `reverse`. It is a boolean set to true on every second connection between anchors.
          </p>
          <label>
            <span><span class="t">Position fn X</span>(Hue / Light)</span>
            <select data-select="x">
            </select>
          </label>
          <label>
            <span><span class="t">Position fn Y</span>(Hue / Light)</span>
            <select data-select="y">
            </select>
          </label>
          <label>
            <span><span class="t">Position fn Z</span> (Saturation)</span>
            <select data-select="z">
            </select>
          </label>
        </div>
      </article>
      <article class="l-sec">
        <div class="l-sec__inner" data-section="closedLoop">
          <h2 id="closedLoop">Looping Palette</h2>
          <p>
            By default, the palette is not a closed loop. This means that the last color generated is not the same as the first color.
            If you want the palette to be a closed loop, you can set the <strong>closedLoop</strong> argument to true.
          </p>
          <pre class="code-ex"><code class="language-js" data-code="closedLoop"></code></pre>
          <p>
            It is also possible to close the loop after the fact by setting <strong>poline.closedLoop = true|false</strong>.
          </p>
          <label>
            <span class="t">Closed Loop<input type="checkbox" checked="checked" data-loop></span>
          </label>
        </div>
      </article>
      <article class="l-sec">
        <div class="l-sec__inner" data-section="hueShift">
          <h2 id="hueShift">Hue Shifting</h2>
          <p>
            "<strong class="t">poline</strong>" supports hue shifting. This means that the hue of the colors will be shifted by a certain amount.
            This can be useful if you want to animate the palette or generate a palette that looks similar to your current palette but using different hues.
          </p>
          <pre class="code-ex"><code class="language-js" data-code="hueShift"></code></pre>
          <p>
            The amount is a int or float between -Infinity and Infinity. It will permanently shift the hue of all colors in the palette.
          </p>
        </div>
      </article>
      <article class="l-sec">
        <div class="l-sec__inner" data-section="closestAnchor">
          <h2 id="closestAnchor">Closest Anchor</h2>
          <p>
            In some situations, you might want to know which anchor is closest to a certain position or color.
            This method is used in the visualizer to highlight to select the closest anchor on click.
          </p>
          <pre class="code-ex"><code class="language-js" data-code="closestAnchor">poline.getClosestAnchorPoint(
  {xyz: [x, y, null], maxDistance: .1}
)</code></pre>
          <p>
            The <strong>maxDistance</strong> argument is optional and will return null if the closest anchor is further away
            than the maxDistance.
          </p>
          <p>
            Any of the <strong>xyz</strong> or <strong>hsl</strong> components can be null. If they are <strong>null</strong>, they will be ignored.
          </p>
        </div>
      </article>
      <article class="l-sec">
        <div class="l-sec__inner" data-section="getColors">
          <h2 id="getColors">Color List</h2>
          <p>
            The '<strong class="t">poline</strong>' instance returns all colors as an array of <strong>hsl</strong> arrays or alternatively as an array of <strong>CSS</strong> strings.
          </p>
          <pre class="code-ex"><code class="language-js" data-code="getColors">poline.colors
poline.colorsCSS</code></pre>
          <figure class="l-sec__preview">
            <figcaption>Colors as HSL</figcaption>
          </figure>
        </div>
      </article>
      <article class="l-sec">
        <div class="l-sec__inner" data-section="colorSpace">
          <h2 id="colorSpace">Color Model</h2>
          <p>
            To keep the library as lightweight as possible, "<strong class="t">poline</strong>" only supports the <strong>hsl</strong> color model out of the box.
            However, it is easily possible to use other color models by using a library like <a href="https://culorijs.org/api/" target="_blank" rel="noopener noreferrer">culori</a>. 
          <pre class="code-ex"><code class="language-js" data-code="colorSpace"></code></pre>
          <label>
            <span class="t">Color Model</span>
            <select data-models>
            </select>
          </label>
        </div>
      </article>
      <!--div class="controls l-sec">
        <div class="l-sec__inner">
          <label>
            <span class="t">Steps</span>
            <input type="range" min="1" max="15" value="3" data-steps>
          </label>
          <label>
            <span class="t">Closed Loop<input type="checkbox" data-loop></span>
          </label>
          <label>
            <span><span class="t">Position fn X</span>(Hue / Light)</span>
            <select data-select="x">
            </select>
          </label>
          <label>
            <span><span class="t">Position fn Y</span>(Hue / Light)</span>
            <select data-select="y">
            </select>
          </label>
          <label>
            <span><span class="t">Position fn Z</span> (Saturation)</span>
            <select data-select="z">
            </select>
          </label>
          <button data-randomize>Randomize</button>
        </div>
      </div-->
    </section>
    <div class="l-demo">
      <div class="poline-picker">
        <div data-picker class="picker"></div>
        <div class="poline-picker__circprev"></div>
      </div>
    </div>
  </main>

  <div class="drawer">
    <h2>Export Colors</h2>
    <div class="drawer__preview">

    </div>
  </div>


  <script type="module">
    console.clear();
    import { formatHex } from 'https://cdn.skypack.dev/culori';
    import hljs from 'https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.7.0/es/highlight.min.js';
    
    import {
      Poline,
      positionFunctions,
      randomHSLPair,
    } from "./index.mjs";

    const svgscale = 100;
    const namespaceURI = 'http://www.w3.org/2000/svg';

    const hueBasedModels = [{
      key: 'okhsl',
      label: 'OKHSL',
      fn: (hsl) => {return {h : hsl[0], s: hsl[1], l: hsl[2]}},
    },
    {
      key: 'hsl',
      label: 'HSL',
      fn: (hsl) => { return { h: hsl[0], s: hsl[1], l: hsl[2] } },
    }
    , {
      key: 'jch',
      label: 'JCH',
      fn: (hsl) => { return { j: hsl[2] * 0.222, c: hsl[1] * 0.190, h: hsl[0] } },
    }, {
      key: 'oklch',
      label: 'OKLCH',
      fn: (hsl) => { return { l: hsl[2] * 0.999, c: hsl[1] * 0.322, h: hsl[0] } },
    }, {
      key: 'lch',
      label: 'LCH',
      fn: (hsl) => { return { l: hsl[2] * 100, c: hsl[1] * 51.484, h: hsl[0] } },
    }, {
        key: 'dlch',
        label: 'DLCH',
        fn: (hsl) => { return { l: hsl[2] * 100, c: hsl[1] * 51.484, h: hsl[0] } },
      }];

    let currentHueModel = 'hsl';
    let currentModelFn = hueBasedModels.find(m => m.key === currentHueModel).fn;

    const stepsToLabels = (steps = 360 / 10) => new Array(steps)
        .fill('')
        .map((_, i) => `
          <strong class="wheel__huelabel" data-huelabel="${i}" style="--i: ${i / steps}">${i * 10}</strong>`)
        .join('')

    const createCSSRainbowGradient = (steps = 360 / 10) => new Array(steps)
        .fill('')
        .map((_, i) => `hsl(${i / (steps - 1) * 360}, calc(var(--s) * 100%), calc(var(--l,0) * 100%))`)
        .join(',');

    const createSVG = (svgscale = 100) => {
      const $svg = document.createElementNS(
        namespaceURI, 'svg'
      );
      $svg.setAttribute('viewBox', `0 0 ${svgscale} ${svgscale}`);
      return $svg;
    }

    const colorArrToSteppedGradient = (colorsArr) => colorsArr.map(
      (c, i) => `${c} ${i / colorsArr.length * 100}% ${(i + 1) / colorsArr.length * 100}%`
    ).join();

    const $steps = document.querySelector('[data-steps]');
    const $selects = document.querySelectorAll('[data-select]');
    const $xSelect = document.querySelector('[data-select="x"]');
    const $ySelect = document.querySelector('[data-select="y"]');
    const $zSelect = document.querySelector('[data-select="z"]');
    const $models = document.querySelector('[data-models]');
    const $loop = document.querySelector('[data-loop]');
    const $randomize = document.querySelector('[data-randomize]');
    const $toc = document.querySelector('[data-toc]');

  
    $models.innerHTML = hueBasedModels
      .map(model => `<option ${model.key == currentHueModel ? 'selected="true"' : ""} value="${model.key}">${model.label}</option>`)
      .join('');
    
    $models.addEventListener('change', (e) => {
      currentHueModel = e.target.value;
      currentModelFn = hueBasedModels.find(m => m.key === currentHueModel).fn;
      updateSVG();
    });

    let fnx = 'sinusoidalPosition';
    let fny = 'quadraticPosition';
    let fnz = 'linearPosition';

    $selects.forEach($select => {
      Object.keys(positionFunctions).forEach(fn => {
        const $option = document.createElement('option');
        if ($select === $xSelect && fn === fnx) $option.selected = true;
        if ($select === $ySelect && fn === fny) $option.selected = true;
        if ($select === $zSelect && fn === fnz) $option.selected = true;
        $option.value = fn;
        $option.textContent = fn;
        $select.appendChild($option);
      });
    });

    let steps = parseInt($steps.value);

    let startHue = Math.random() * 360;

    let poline = new Poline({
      /*anchorColors: [
        [startHue, Math.random(), 0.8],
        [(startHue + 60 + Math.random() * 180) % 360, Math.random(), Math.random() * .2],
        [(startHue + 60 + Math.random() * 180) % 360, Math.random(), .8]
      ],*/
      numPoints: steps,
      positionFunctionX: positionFunctions[fnx],
      positionFunctionY: positionFunctions[fny],
      positionFunctionZ: positionFunctions[fnz],
      closedLoop: false,
    });

    const $picker = document.querySelector('[data-picker]');
    const hueSteps = 360 / 10;
    
    const $svg = createSVG(svgscale);
    $picker.innerHTML = stepsToLabels(hueSteps);
    const $huelabels = document.querySelectorAll('[data-huelabel]');
    $picker.appendChild($svg);
    
    $picker.style.setProperty('--grad', createCSSRainbowGradient(hueSteps));

    //const hue = Math.random() * 360;

    //poline.addAnchorPoint({color: [(startHue + 60 + Math.random() * 180) % 360, Math.random(), .8] });    
    //poline.addAnchorPoint({color: poline.anchorPoints[0].color});
    //console.log(poline);

    function updateSVG () {
      $huelabels.forEach(($huelabel, i) => {
        $huelabel.classList.remove('wheel__huelabel--active');
        // if the HUE label is within the range of the current anchor point
        poline.anchorPoints.forEach(anchor => {
          const currentHue = anchor.color[0];
          currentHue - hueSteps / 2 < i * 10 && currentHue + hueSteps / 2 > i * 10 && $huelabel.classList.add('wheel__huelabel--active');
        });
      });

      $svg.innerHTML = '';

      poline.anchorPoints.forEach(anchor => {
        const $circle = document.createElementNS(namespaceURI, 'circle');
        $circle.setAttribute('cx', anchor.x * svgscale);
        $circle.setAttribute('cy', anchor.y * svgscale);
        $circle.setAttribute('r', 2)
        //anchor.hslCSS
        $circle.classList.add('wheel__anchor');
        $circle.setAttribute('fill', '#fff');
        $svg.appendChild($circle);
      });

      poline.flattenedPoints.forEach((point, i) => {
        const $line = document.createElementNS(namespaceURI, 'line');
        $line.classList.add('wheel__line');
        $line.setAttribute('x1', point.x * svgscale);
        $line.setAttribute('y1', point.y * svgscale);
        const nextI = (i + 1) % poline.flattenedPoints.length;
        $line.setAttribute('x2', poline.flattenedPoints[nextI].x * svgscale);
        $line.setAttribute('y2', poline.flattenedPoints[nextI].y * svgscale);
        if (i !== poline.flattenedPoints.length - 1) {
          $svg.appendChild($line);
        }

        const $circle = document.createElementNS(namespaceURI, 'circle');
        $circle.setAttribute('cx', point.x * svgscale);
        $circle.setAttribute('cy', point.y * svgscale);
        $circle.setAttribute('r', .5 + point.color[1] * 1)
        $circle.classList.add('wheel__point');
        $circle.setAttribute('fill', formatHex({ mode: currentHueModel, ...currentModelFn(point.color) }) );
        $svg.appendChild($circle);
      });
      
      let cssColors = [...poline.colorsCSS];
      let colors = [...poline.colors].map(c => formatHex({ mode: currentHueModel, ...currentModelFn(c) }));
      //colors = [...poline.colors].map(c => formatCss({ mode: 'p3', ...currentModelFn(c) }));
      document.documentElement.style.setProperty(
        '--prev',
        colorArrToSteppedGradient(colors)
      )

      document.documentElement.style.setProperty(
        '--prev-smooth',
        colors.join(',')
      )
    }

    updateSVG();

    $loop.addEventListener('input', () => {
      poline.closedLoop = $loop.checked;
      updateSVG();
    });

    $steps.addEventListener('input', () => {
      steps = parseInt($steps.value);
      poline.numPoints = steps;
      updateSVG();
    });

    $xSelect.addEventListener('input', () => {
      fnx = $xSelect.value;
      poline.positionFunctionX = positionFunctions[fnx];
      updateSVG();
    });

    $ySelect.addEventListener('input', () => {
      fny = $ySelect.value;
      poline.positionFunctionY = positionFunctions[fny];
      updateSVG();
    });

    $zSelect.addEventListener('input', () => {
      fnz = $zSelect.value;
      poline.positionFunctionZ = positionFunctions[fnz];
      updateSVG();
    });

    $randomize.addEventListener('click', () => {
      poline.anchorPoints.forEach(anchor => {
        anchor.hsl = [
          (anchor.color[0] + (-90 + Math.random() * 90)) % 360,
          Math.random(),
          anchor.color[2] + (-.05 + Math.random() * .1)
        ];
      });
      poline.updatePointPairs();
      updateSVG();
    });

    let currentPoint = null;
    let lastSelectedPoint = null;
    let lastX = 0;
    let lastY = 0;

    $picker.addEventListener('pointerdown', (e) => {
      const x = lastX = e.offsetX / $picker.offsetWidth;
      const y = lastY = e.offsetY / $picker.offsetHeight;

      if (!currentPoint) {
        
        currentPoint = poline.getClosestAnchorPoint({ 
          xyz: [x, y, null], 
          maxDistance: .1 
        });
        lastSelectedPoint = currentPoint;
      } else {
        currentPoint = null;
      }
    });

    $picker.addEventListener('pointermove', (e) => {
      const x = lastX = e.offsetX / $picker.offsetWidth;
      const y = lastY = e.offsetY / $picker.offsetHeight;

      if (currentPoint) {
        poline.updateAnchorPoint({point: currentPoint, xyz: [x, y, currentPoint.z]});
        updateSVG();
      } 
    });

  
  /*
  setInterval(() => {
    poline.anchorPoints[0].hsl = [
      (poline.anchorPoints[0].color[0] + 1) % 360,
      poline.anchorPoints[0].color[1],
      poline.anchorPoints[0].color[2]
    ];

    poline.anchorPoints[2].hsl = [
      (poline.anchorPoints[2].color[0] - 1) % 360,
      poline.anchorPoints[2].color[1],
      poline.anchorPoints[2].color[2]
    ];

    poline.updatePointPairs();
    updateSVG();
  }, 16.66);
  */
  


  $picker.addEventListener('pointerup', (e) => {
    currentPoint = null;
  });

  // listen for keypresses
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Delete' || e.key === 'Backspace') {
      if (!lastSelectedPoint) return;
      poline.removeAnchorPoint(lastSelectedPoint);
      updateSVG();
    }

    if (e.key === 'p') {
      lastSelectedPoint = poline.addAnchorPoint({xyz: [lastX, lastY, lastY]});
      updateSVG();
    }
  });

  let exStartHue = Math.random() * 360;
  let globalInterval = null;

  // scripts per section
  const storyScripts = [{
    section: 'intro',
    fn: () => {
      console.log('intro');
      poline = new Poline({
        numPoints: steps,
      });
      updateSVG();
    },
  },
  {
    section: 'summoning',
    fn: (section) => {
      console.log('summoning');
      exStartHue = Math.random() * 360;
      poline = new Poline({
        anchorColors: [
          [exStartHue, Math.random(), 0.8],
          [(exStartHue + 60 + Math.random() * 180) % 360, Math.random(), Math.random() * .2],
          /*[(exStartHue + 60 + Math.random() * 180) % 360, Math.random(), .8]*/
        ],
      });
      updateSVG();
      const $code = section.target.querySelector('[data-code]');
      $code.innerHTML = `new Poline({
  anchorColors: [
    [${
      Math.round(poline.anchorPoints[0].color[0])
    }, ${
      poline.anchorPoints[0].color[1].toFixed(2)
    }, ${
      poline.anchorPoints[0].color[2].toFixed(2)
    }],
    [${
      Math.round(poline.anchorPoints[1].color[0])
    }, ${
      poline.anchorPoints[1].color[1].toFixed(2)
    }, ${
      poline.anchorPoints[1].color[2].toFixed(2)
    }],
  ],
});`;

    hljs.highlightElement($code);
    },
  },
  {
    section: 'points',
    fn: (section) => {
      console.log('points');
      poline.numPoints = 6;
      updateSVG();
      const $code = section.target.querySelector('[data-code]');
      $code.innerHTML = `new Poline({
  numPoints: 6,
});`;
      hljs.highlightElement($code);
    },
  },
  {
    section: 'anchors',
    fn: (section) => {
      console.log('anchors');
      if (poline.anchorPoints.length > 2) {
        poline.anchorPoints.forEach((anchor, i) => {
          if (i > 1) poline.removeAnchorPoint(anchor);
        });
      }
      poline.addAnchorPoint({color: [(exStartHue + 60 + Math.random() * 180) % 360, Math.random(), .8] });
      const $code = section.target.querySelector('[data-code]');
      $code.innerHTML = `poline.addAnchorPoint({
  color: [${
        Math.round(poline.anchorPoints[poline.anchorPoints.length - 1].color[0])
      }, ${
        poline.anchorPoints[poline.anchorPoints.length - 1].color[1].toFixed(2)
      }, ${
        poline.anchorPoints[poline.anchorPoints.length - 1].color[2].toFixed(2)
      }]
});`;
      hljs.highlightElement($code);
      updateSVG();
    }
  },
  {
    section: 'positionFunctions',
    fn: (section) => {
      console.log('Position Functions');
      if (poline.anchorPoints.length > 3) {
        poline.anchorPoints.forEach((anchor, i) => {
          if (i > 1) poline.removeAnchorPoint(anchor);
        });
      }
      poline.closedLoop = false;
      poline.positionFunctionX = positionFunctions[fnx];
      poline.positionFunctionY = positionFunctions[fny];
      poline.positionFunctionZ = positionFunctions[fnz];
      poline.updatePointPairs();
      const $code = section.target.querySelector('[data-code]');
      $code.innerHTML = `import {
  Poline, positionFunctions
} from 'poline';

new Poline({
  positionFunctionX: 
    positionFunctions.${poline.positionFunctionX.name},
  positionFunctionY: 
    positionFunctions.${poline.positionFunctionY.name},
  positionFunctionZ: 
    positionFunctions.${poline.positionFunctionZ.name},
});`;
      hljs.highlightElement($code);
      updateSVG();
    },
  },
  {
    section: 'closedLoop',
    fn: (section) => {
      console.log('closedLoop');
      poline.closedLoop = true;
      poline.updatePointPairs();
      const $code = section.target.querySelector('[data-code]');
      $code.innerHTML = `new Poline({
  closedLoop: true,
});`;
      hljs.highlightElement($code);
      updateSVG()
    },
  },
  {
    section: 'UpdatingAnchors',
    fn: (section) => {
      console.log('Updating Anchors');
      poline.anchorPoints.forEach((anchor, i) => {
        const hsl = anchor.color;
        poline.updateAnchorPoint({
          point: anchor,
          color: [
            hsl[0] + Math.random() * 60 - 30,
            hsl[1],
            hsl[1],
          ],
        });
      });
      const $code = section.target.querySelector('[data-code]');
      $code.innerHTML = `poline.updateAnchorPoint({
  point: poline.anchorPoints[0],
  color: [${
      Math.round(poline.anchorPoints[0].color[0])
    }, ${
      poline.anchorPoints[0].color[1].toFixed(2)
    }, ${
      poline.anchorPoints[0].color[2].toFixed(2)
    }]
});`;
      hljs.highlightElement($code);
      updateSVG();
    }, 
  },
  {
    section: 'closestAnchor',
    fn: (section) => {
      console.log('closestAnchor');
      const $code = section.target.querySelector('[data-code]');
      hljs.highlightElement($code);
    },
  },
  {
    section: 'colorSpace',
    fn: (section) => {
      console.log('colorSpace');
      const $code = section.target.querySelector('[data-code]');
      $code.innerHTML = `import {Poline} from "poline";
import {formatHex} from "culori";
const poline = new Poline(/** options */);

const OKHslColors = [...poline.colors].map(
  c => formatHex({ 
    mode: 'okhsl', 
    {
      h: c.hsl[0], 
      s: c.hsl[1], 
      l: c.hsl[2]}
  })
);
const LCHColors = [...poline.colors].map(
  c => formatHex({ 
    mode: 'lch', 
    { 
      h: hsl[0],
      c: hsl[1] * 51.484,
      l: hsl[2] * 100,  
    }
  })
);`
      hljs.highlightElement($code);
      updateSVG();
    },
  },
  {
    section: 'hueShift',
    fn: (section) => {
      console.log('hueShift');
      const $code = section.target.querySelector('[data-code]');
      $code.innerHTML = `poline.shiftHue(1);`;
      globalInterval = setInterval(() => {
        poline.shiftHue(1);
        updateSVG();
      }, 16.66);
    }
  },
  {
    section: 'getColors',
    fn: (section) => {
      console.log('getColors');
      const $code = section.target.querySelector('[data-code]');
      hljs.highlightElement($code);
      updateSVG();
    },
  }
];
  
  // create a table of contents
  const $sections = document.querySelectorAll('[data-section]');
  $sections.forEach($s => {
    const $h2 = $s.querySelector('h2');
    if ($h2) {
      const $li = document.createElement('li');
      $li.innerHTML = `<a href="#${$h2.id}">${$h2.innerHTML}</a>`;
      $toc.appendChild($li);
    }
  });

  $toc.addEventListener('click', (e) => {
    e.preventDefault();
    const $a = e.target;
    if ($a.tagName !== 'A') return;
    const $h2 = document.querySelector(`#${$a.getAttribute('href').replace('#', '')}`);
    $h2.scrollIntoView({behavior: 'smooth'});
  });

  // create an intersection onserver for all the `data-section`s
  const sections = [...document.querySelectorAll('[data-section]')];
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        // find the script for this section in storyScripts
        const script = storyScripts.find(s => s.section === entry.target.dataset.section);
        if (script) {
          clearInterval(globalInterval);
          script.fn(entry);
        }
        // add .l-sec--active to the section when it's in view
        // and remove it on all other sections
        sections.forEach(section => {
          if (section === entry.target) {
            section.parentElement.classList.add('l-sec--active');
          } else {
            section.parentElement.classList.remove('l-sec--active');
          }
        });
        
      }
    });
  }, {
    rootMargin: '0px 0px -50% 0px'
  });

  sections.forEach(section => {
    observer.observe(section);
  });
  </script>
</body>

</html>