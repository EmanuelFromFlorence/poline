<!DOCTYPE html>

<html lang="en">

<head>
  <meta charset="utf-8" />
  <!-- Primary Meta Tags -->
  <title>Poline</title>
  <!-- Primary Meta Tags -->
  <title>Poline — esoteric color palette generator</title>
  <meta name="title" content="Poline —  esoteric color palette generator">
  <meta name="description"
    content="poline is lightweight, dependency free and fast JavaScript function written in TypeScript. It draws lines between anchors over polar coordinates to generate pleasing color palettes.">

  <!-- Open Graph / Facebook -->
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://meodai.github.io/poline/">
  <meta property="og:title" content="Poline —  esoteric color palette generator">
  <meta property="og:description"
    content="poline is lightweight, dependency free and fast JavaScript function written in TypeScript. It draws lines between anchors over polar coordinates to generate pleasing color palettes.">
  <meta property="og:image" content="https://meodai.github.io/poline/socialfb.png">

  <!-- Twitter -->
  <meta property="twitter:card" content="summary_large_image">
  <meta property="twitter:url" content="https://meodai.github.io/poline/">
  <meta property="twitter:title" content="Poline —  esoteric color palette generator">
  <meta property="twitter:description"
    content="poline is lightweight, dependency free and fast JavaScript function written in TypeScript. It draws lines between anchors over polar coordinates to generate pleasing color palettes.">
  <meta property="twitter:image" content="https://meodai.github.io/poline/socialfb.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Aboreto&family=Work+Sans:wght@300;400&display=swap" rel="stylesheet">
  
  <style>
    :root {
      background: #fff;
      color: #202124;

      font-family: 'Work Sans', sans-serif;
      font-weight: 300;
      font-size: 0.9rem;
    }

    h1, h2, h3, .t, .wheel__huelabel {
      font-family: 'Aboreto', cursive;
    }

    h1 {
      font-size: 5rem;
      margin: 0;
      padding: 0;
      font-weight: normal;
      letter-spacing: -0.05em;
      margin-left: -0.06em;
    }

    h2 {
      font-size: 2.5rem;
      margin: 0;
      padding: 0;
      font-weight: normal;
      letter-spacing: -0.05em;
      margin-left: -0.06em;
    }

    .t-intro {
      margin: 3em 0 1em;
    }


    p {
      line-height: 1.5;
    }

    .poline-picker {
      position: absolute;
      width: min(60vmin, 60%);
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }

    .poline-picker__circprev {
      width: 12vmin;
      height: 12vmin;
      background: conic-gradient(var(--prev));
      border-radius: 50%;
      position: absolute;
      top: 100%;
      left: 50%;
      z-index: 3;
      transition: transform 0.5s cubic-bezier(0.3, 0.7, 0, 1);
      box-shadow: 0 0 0 0.7vmin #fff;
      pointer-events: none;
      transform: translate(-50%, -50%) scale(0.4);
    }

    .picker {
      position: relative;
      width: 100%;
      aspect-ratio: 1;
      --s: .4;
      --l: .5;
      border-radius: 50%;
      background: radial-gradient(closest-side, #000, rgba(255, 255, 255, 0), #fff), conic-gradient(from 90deg, var(--grad));
    }

    svg {
      position: relative;
      z-index: 2;
      overflow: visible !important;
      width: 100%;
    
    }

    svg line.wheel__line {
      stroke: #202124;
      stroke-width: 0.25;
      stroke-dasharray: 0.5 0.5;
      pointer-events: none;
    }

    svg circle {
      stroke: #000;
      stroke-width: 0.25;
    }

    svg .wheel__point {
      pointer-events: none;
    }

    svg .wheel__anchor {
      pointer-events: all;
      cursor: grab;
    }

    svg line.wheel__satline {
      stroke-dasharray: 0 0;
      stroke-width: 1;
      stroke-linecap: round;
    }

    svg line.wheel__satline--bg {
      stroke: #fff;
      stroke-width: 1.5;
      stroke-dasharray: 0 0;
    }

    .wheel__huelabel {
      user-select: none;
      pointer-events: none;
      font-weight: normal;
      box-sizing: border-box;
      position: absolute;
      top: 50%;
      left: 50%;
      width: calc(100% + 16vmin);
      transform: translate(-50%, -50%) rotate(calc(var(--i, 0) * 360deg));
      font-size: 1.7vmin;
      padding: 0.2em 3em 0.2em 120.5%;
      z-index: 1;
      text-align: right;
      pointer-events: none;
      transition: font-size 0.3s cubic-bezier(.3,.7,0,1);
    }

    .picker:hover .wheel__huelabel {
      font-size: 1vmin;
    }

    .picker:hover .wheel__huelabel--active {
      font-size: 1.7vmin;
    }

    .wheel__huelabel::before,
    .wheel__huelabel::after {
      content: "";
      position: absolute;
      bottom: 50%;
      left: 91%;
      right: 6vmin;
      height: 1px;
      background: #202124;
      transform: translateY(50%);
    }

    .wheel__huelabel::after {
      height: 30%;
      aspect-ratio: 1;
      right: auto;
      left: 90%;
      background: hsl(calc(360 * var(--i, 0)), 100%, 70%);
      border-radius: 50%;
      border: 1px solid #fff;
      transform: translate(-50%, 50%) scale(1);
      transition: transform 0.2s ease-in-out;
    }

    .wheel__huelabel--active::after {
      transform: translate(-50%, 50%) scale(1.2);
    }

    label {
      display: block;
      margin: 1rem 0;
      font-size: .8rem;
    }
    label .t {
      display: block;
      margin: 0;
      font-size: 1rem;
    }
    select {
      margin-top: 1em;
      display: block;
      width: 100%;
      padding: 0;
      border: none;
      font: inherit;
      font-family: inherit;

      font-size: .8rem;
      text-decoration: underline;
    }
    .controls {
    }

    button {
      font-family: 'Aboreto', cursive;
      background-color: #202125;
      color: #fff;
    }

    .l-wrap {
      display: flex;
    }

    .l-menu {
      flex: 0 0 30%;
      width: 30%;
      box-sizing: border-box;
      padding: 0 0 0 5rem;
    }

    .l-demo {
      position: fixed;
      width: 70%;
      height: 100%;
      right: 0;
    }
    
    .drawer {
      --preview-width: 2rem;
      position: fixed;
      top: 0;
      left: 0;
      bottom: 0;
      width: 30%;
      background: #202125;
      transform: translateX(calc(-100% + var(--preview-width)));
    }

    .drawer__preview {
      position: absolute;
      right: 0;
      bottom: 0;
      top: 0;
      width: var(--preview-width);

      background: linear-gradient(0deg, var(--prev));
    }
    .drawer__preview::before,
    .drawer__preview::after {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      background: linear-gradient(0deg, var(--prev-smooth));
    }
    .drawer__preview::after {
      right: 0;
      width: 1rem;
      left: auto;
      display: none;
    }
    .drawer__preview::before {
      z-index: -1;
      transform: translateX(1rem) scaleY(1.1);
      filter: blur(15px);
      opacity: 0.5;
      right: 0;
    }
    .l-sec {
      min-height: 20vh;
    }
    .l-sec--intro {
      min-height: 100vh;
      display: flex;
      align-items: center;
    }
    .l-sec__inner {
      width: 100%;
    }
    code {
      display: block;
      font-family: 'Work Sans', sans-serif;
      font-size: .9rem;
      color: #fff;
      background: #202125;
      padding: 1.5em 1.2em;
      border-radius: 0.2em;
    }
  </style>
</head>

<body>
  <main class="l-wrap">
    <section class="l-menu">
      <div class="l-sec l-sec--intro">
        <div class="l-sec__inner">
          <h1>Poline</h1>
          <p class="t-intro">
            "<strong class="t">poline</strong>" is an enigmatic color palette generator, that harnesses the mystical witchcraft of polar coordinates. Its
            methodology, defying conventional color science, is steeped in the esoteric knowledge of the early 20th century. This
            magical technology defies explanation, drawing lines between anchors to produce visually striking and otherworldly
            palettes. It is an indispensable tool for the modern generative sorcerer, and a delight for the eye.
          </p>
        </div>
      </div>
      <article class="l-sec">
        <h2>Summoning</h2>
        <p>
          When summoning a "<strong class="t">poline</strong>" without providing any arguments. 
          It will generate a palette with two random <strong>anchors</strong>. However, you can also
          provide a list of <strong>anchors</strong> to the function. The <strong>anchors</strong> are
          represented as a list of <strong>hsl</strong> values.
          <pre><code>poline({
  anchorColors: [[0, 1, 0.2], [120, 0.6, 0.8]]
})</code></pre>
        </p>
      </article>
      <article class="l-sec">
        <h2></h2>
      </article>
      <div class="controls l-sec">
        <div class="l-sec__inner">
          <label>
            <span class="t">Steps</span>
            <input type="range" min="3" max="15" value="3" data-steps>
          </label>
          <label>
            <span class="t">Closed Loop<input type="checkbox" data-loop></span>
          </label>
          <label>
            <span><span class="t">Position fn X</span>(Hue / Light)</span>
            <select data-select="x">
            </select>
          </label>
          <label>
            <span><span class="t">Position fn Y</span>(Hue / Light)</span>
            <select data-select="y">
            </select>
          </label>
          <label>
            <span><span class="t">Position fn Z</span> (Saturation)</span>
            <select data-select="z">
            </select>
          </label>
          <label>
            <span class="t">Hue Shift</span>
            <input type="range" min="-10" max="10" value="0" step="0.1" data-hueshift>
          </label>
          <label>
            <span class="t">Color Model</span>
            <select data-models>
            </select>
          </label>
          <button data-randomize>Randomize</button>
        </div>
      </div>
    </section>
    <div class="l-demo">
      <div class="poline-picker">
        <div data-picker class="picker"></div>
        <div class="poline-picker__circprev"></div>
      </div>
    </div>
  </main>

  <div class="drawer">
    <h2>Export Colors</h2>
    <div class="drawer__preview">

    </div>
  </div>


  <script type="module">
    console.clear();
    import { formatHex } from 'https://cdn.skypack.dev/culori';
    
    import {
      Poline,
      positionFunctions,
      randomHSLPair,
    } from "./index.mjs";

    const svgscale = 100;
    const namespaceURI = 'http://www.w3.org/2000/svg';

    const hueBasedModels = [{
      key: 'okhsl',
      label: 'OKHSL',
      fn: (hsl) => {return {h : hsl[0], s: hsl[1], l: hsl[2]}},
    },
    {
      key: 'hsl',
      label: 'HSL',
      fn: (hsl) => { return { h: hsl[0], s: hsl[1], l: hsl[2] } },
    }
    , {
      key: 'jch',
      label: 'JCH',
      fn: (hsl) => { return { j: hsl[2] * 0.222, c: hsl[1] * 0.190, h: hsl[0] } },
    }, {
      key: 'oklch',
      label: 'OKLCH',
      fn: (hsl) => { return { l: hsl[2] * 0.999, c: hsl[1] * 0.322, h: hsl[0] } },
    }, {
      key: 'lch',
      label: 'LCH',
      fn: (hsl) => { return { l: hsl[2] * 100, c: hsl[1] * 51.484, h: hsl[0] } },
    }, {
        key: 'dlch',
        label: 'DLCH',
        fn: (hsl) => { return { l: hsl[2] * 100, c: hsl[1] * 51.484, h: hsl[0] } },
      }];

    let currentHueModel = 'hsl';
    let currentModelFn = hueBasedModels.find(m => m.key === currentHueModel).fn;

    const stepsToLabels = (steps = 360 / 10) => new Array(steps)
        .fill('')
        .map((_, i) => `
          <strong class="wheel__huelabel" data-huelabel="${i}" style="--i: ${i / steps}">${i * 10}</strong>`)
        .join('')

    const createCSSRainbowGradient = (steps = 360 / 10) => new Array(steps)
        .fill('')
        .map((_, i) => `hsl(${i / (steps - 1) * 360}, calc(var(--s) * 100%), calc(var(--l,0) * 100%))`)
        .join(',');

    const createSVG = (svgscale = 100) => {
      const $svg = document.createElementNS(
        namespaceURI, 'svg'
      );
      $svg.setAttribute('viewBox', `0 0 ${svgscale} ${svgscale}`);
      return $svg;
    }

    const colorArrToSteppedGradient = (colorsArr) => colorsArr.map(
      (c, i) => `${c} ${i / colorsArr.length * 100}% ${(i + 1) / colorsArr.length * 100}%`
    ).join();

    const $steps = document.querySelector('[data-steps]');
    const $selects = document.querySelectorAll('[data-select]');
    const $xSelect = document.querySelector('[data-select="x"]');
    const $ySelect = document.querySelector('[data-select="y"]');
    const $zSelect = document.querySelector('[data-select="z"]');
    const $models = document.querySelector('[data-models]');
    const $loop = document.querySelector('[data-loop]');
    const $hueshift = document.querySelector('[data-hueshift]');
    const $randomize = document.querySelector('[data-randomize]');

    $models.innerHTML = hueBasedModels
      .map(model => `<option ${model.key == currentHueModel ? 'selected="true"' : ""} value="${model.key}">${model.label}</option>`)
      .join('');
    
    $models.addEventListener('change', (e) => {
      currentHueModel = e.target.value;
      currentModelFn = hueBasedModels.find(m => m.key === currentHueModel).fn;
      updateSVG();
    });

    let fnx = 'sinusoidalPosition';
    let fny = 'quadraticPosition';
    let fnz = 'linearPosition';

    $selects.forEach($select => {
      Object.keys(positionFunctions).forEach(fn => {
        const $option = document.createElement('option');
        if ($select === $xSelect && fn === fnx) $option.selected = true;
        if ($select === $ySelect && fn === fny) $option.selected = true;
        if ($select === $zSelect && fn === fnz) $option.selected = true;
        $option.value = fn;
        $option.textContent = fn;
        $select.appendChild($option);
      });
    });

    let steps = parseInt($steps.value);

    let startHue = Math.random() * 360;

    let poline = new Poline({
      /*anchorColors: [
        [startHue, Math.random(), 0.8],
        [(startHue + 60 + Math.random() * 180) % 360, Math.random(), Math.random() * .2],
        [(startHue + 60 + Math.random() * 180) % 360, Math.random(), .8]
      ],*/
      numPoints: steps,
      positionFunctionX: positionFunctions[fnx],
      positionFunctionY: positionFunctions[fny],
      positionFunctionZ: positionFunctions[fnz],
      closedLoop: false,
    });

    const $picker = document.querySelector('[data-picker]');
    const hueSteps = 360 / 10;
    
    const $svg = createSVG(svgscale);
    $picker.innerHTML = stepsToLabels(hueSteps);
    const $huelabels = document.querySelectorAll('[data-huelabel]');
    $picker.appendChild($svg);
    
    $picker.style.setProperty('--grad', createCSSRainbowGradient(hueSteps));

    //const hue = Math.random() * 360;

    //poline.addAnchorPoint({color: [(startHue + 60 + Math.random() * 180) % 360, Math.random(), .8] });    
    //poline.addAnchorPoint({color: poline.anchorPoints[0].color});
    //console.log(poline);

    function updateSVG () {
      $huelabels.forEach(($huelabel, i) => {
        $huelabel.classList.remove('wheel__huelabel--active');
        // if the HUE label is within the range of the current anchor point
        poline.anchorPoints.forEach(anchor => {
          const currentHue = anchor.color[0];
          currentHue - hueSteps / 2 < i * 10 && currentHue + hueSteps / 2 > i * 10 && $huelabel.classList.add('wheel__huelabel--active');
        });
      });

      $svg.innerHTML = '';

      poline.anchorPoints.forEach(anchor => {
        const $circle = document.createElementNS(namespaceURI, 'circle');
        $circle.setAttribute('cx', anchor.x * svgscale);
        $circle.setAttribute('cy', anchor.y * svgscale);
        $circle.setAttribute('r', 2)
        //anchor.hslCSS
        $circle.classList.add('wheel__anchor');
        $circle.setAttribute('fill', '#fff');
        $svg.appendChild($circle);
      });

      poline.flattenedPoints.forEach((point, i) => {
        const $line = document.createElementNS(namespaceURI, 'line');
        $line.classList.add('wheel__line');
        $line.setAttribute('x1', point.x * svgscale);
        $line.setAttribute('y1', point.y * svgscale);
        const nextI = (i + 1) % poline.flattenedPoints.length;
        $line.setAttribute('x2', poline.flattenedPoints[nextI].x * svgscale);
        $line.setAttribute('y2', poline.flattenedPoints[nextI].y * svgscale);
        if (i !== poline.flattenedPoints.length - 1) {
          $svg.appendChild($line);
        }

        const $circle = document.createElementNS(namespaceURI, 'circle');
        $circle.setAttribute('cx', point.x * svgscale);
        $circle.setAttribute('cy', point.y * svgscale);
        $circle.setAttribute('r', .5 + point.color[1] * 1)
        $circle.classList.add('wheel__point');
        $circle.setAttribute('fill', formatHex({ mode: currentHueModel, ...currentModelFn(point.color) }) );
        $svg.appendChild($circle);

        /*
        // create a vertical line with a height representing the saturation
        const $vline = document.createElementNS(namespaceURI, 'line');
        const $vlineBG = document.createElementNS(namespaceURI, 'line');
        $vlineBG.setAttribute('x1', point.x * svgscale);
        $vline.setAttribute('x1', point.x * svgscale);

        $vline.setAttribute('y1', point.y * svgscale);
        $vlineBG.setAttribute('y1', point.y * svgscale);

        $vline.setAttribute('x2', point.x * svgscale);
        $vlineBG.setAttribute('x2', point.x * svgscale);

        $vline.setAttribute('y2', point.y * svgscale - point.color[1] * 7);
        $vlineBG.setAttribute('y2', point.y * svgscale - point.color[1] * 7);
        $vline.setAttribute('stroke', point.hslCSS);
        $vline.classList.add('wheel__satline');
        $vlineBG.setAttribute('stroke', '#fff');
        $vlineBG.classList.add('wheel__satline', 'wheel__satline--bg');
        $svg.appendChild($vlineBG);
        $svg.appendChild($vline);
        */
      });
      
      let cssColors = [...poline.colorsCSS];
      let colors = [...poline.colors].map(c => formatHex({ mode: currentHueModel, ...currentModelFn(c) }));
      //colors = [...poline.colors].map(c => formatCss({ mode: 'p3', ...currentModelFn(c) }));
      document.documentElement.style.setProperty(
        '--prev',
        colorArrToSteppedGradient(colors)
      )

      document.documentElement.style.setProperty(
        '--prev-smooth',
        colors.join(',')
      )

    }

    updateSVG();

    $loop.addEventListener('input', () => {
      poline.closedLoop = $loop.checked;
      updateSVG();
    });

    $steps.addEventListener('input', () => {
      steps = parseInt($steps.value);
      poline.numPoints = steps;
      poline.updatePointPairs();

      updateSVG();
    });

    $xSelect.addEventListener('input', () => {
      fnx = $xSelect.value;
      poline.positionFunction = positionFunctions[fnx];
      poline.updatePointPairs();
      updateSVG();
    });

    $ySelect.addEventListener('input', () => {
      fny = $ySelect.value;
      poline.positionFunctionY = positionFunctions[fny];
      poline.updatePointPairs();
      updateSVG();
    });

    $zSelect.addEventListener('input', () => {
      fnz = $zSelect.value;
      poline.positionFunctionZ = positionFunctions[fnz];
      poline.updatePointPairs();
      updateSVG();
    });

    $randomize.addEventListener('click', () => {

      poline.anchorPoints.forEach(anchor => {
        anchor.hsl = [
          (anchor.color[0] + (-90 + Math.random() * 90)) % 360,
          Math.random(),
          anchor.color[2] + (-.05 + Math.random() * .1)
        ];
      });
      poline.updatePointPairs();
      updateSVG();
    });

    let currentPoint = null;
    let lastSelectedPoint = null;
    let lastX = 0;
    let lastY = 0;


    $picker.addEventListener('pointerdown', (e) => {
      const x = lastX = e.offsetX / $picker.offsetWidth;
      const y = lastY = e.offsetY / $picker.offsetHeight;

      if (!currentPoint) {
        currentPoint = poline.getClosestAnchorPoint([x, null, y], .1);
        lastSelectedPoint = currentPoint;
      } else {
        currentPoint = null;
      }
    });

    $picker.addEventListener('pointermove', (e) => {
      const x = lastX = e.offsetX / $picker.offsetWidth;
      const y = lastY = e.offsetY / $picker.offsetHeight;

      if (currentPoint) {
        currentPoint.position = [x, y, currentPoint.z];
        poline.updatePointPairs();
        updateSVG();
      } 
    });

  
  /*
  setInterval(() => {
    poline.anchorPoints[0].hsl = [
      (poline.anchorPoints[0].color[0] + 1) % 360,
      poline.anchorPoints[0].color[1],
      poline.anchorPoints[0].color[2]
    ];

    poline.anchorPoints[2].hsl = [
      (poline.anchorPoints[2].color[0] - 1) % 360,
      poline.anchorPoints[2].color[1],
      poline.anchorPoints[2].color[2]
    ];

    poline.updatePointPairs();
    updateSVG();
  }, 16.66);
  */
  


  $picker.addEventListener('pointerup', (e) => {
    currentPoint = null;
  });

  // listen for keypresses
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Delete' || e.key === 'Backspace') {
      if (!lastSelectedPoint) return;
      poline.removeAnchorPoint(lastSelectedPoint);
      updateSVG();
    }

    if (e.key === 'p') {
      lastSelectedPoint = poline.addAnchorPoint({x: lastX, y: lastY, z: lastY});
      updateSVG();
    }
  });


  $hueshift.addEventListener('input', (e) => {
    poline.shiftHue(parseFloat(e.target.value));

    updateSVG();
  });

  </script>
</body>

</html>