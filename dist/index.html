<!DOCTYPE html>

<html lang="en">

<head>
  <meta charset="utf-8" />
  <!-- Primary Meta Tags -->
  <title>Poline — esoteric color palette generator</title>
  <meta name="title" content="Poline —  esoteric color palette generator">
  <meta name="description"
    content="poline is lightweight, dependency free and fast JavaScript function written in TypeScript. It draws lines between anchors over polar coordinates to generate pleasing color palettes.">

  <!-- Open Graph / Facebook -->
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://meodai.github.io/poline/">
  <meta property="og:title" content="Poline —  esoteric color palette generator">
  <meta property="og:description"
    content="poline is lightweight, dependency free and fast JavaScript function written in TypeScript. It draws lines between anchors over polar coordinates to generate pleasing color palettes.">
  <meta property="og:image" content="https://meodai.github.io/poline/socialfb.png">

  <!-- Twitter -->
  <meta property="twitter:card" content="summary_large_image">
  <meta property="twitter:url" content="https://meodai.github.io/poline/">
  <meta property="twitter:title" content="Poline —  esoteric color palette generator">
  <meta property="twitter:description"
    content="poline is lightweight, dependency free and fast JavaScript function written in TypeScript. It draws lines between anchors over polar coordinates to generate pleasing color palettes.">
  <meta property="twitter:image" content="https://meodai.github.io/poline/socialfb.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Aboreto&family=Work+Sans:wght@300;400&display=swap" rel="stylesheet">
  
  <style>
    :root {
      background: #fff;
      color: #202124;

      font-family: 'Work Sans', sans-serif;
      font-weight: 300;
      font-size: 0.9rem;
    }

    h1, h2, h3, .t, .wheel__huelabel {
      font-family: 'Aboreto', cursive;
    }

    h1 {
      font-size: 5rem;
      margin: 0;
      padding: 0;
      font-weight: normal;
      letter-spacing: -0.05em;
      margin-left: -0.06em;
    }

    h2 {
      font-size: 2.5rem;
      margin: 0;
      padding: 0;
      font-weight: normal;
      letter-spacing: -0.05em;
      margin-left: -0.06em;
    }

    .t-intro {
      margin: 3em 0 1em;
    }


    p {
      line-height: 1.5;
    }

    .poline-picker {
      position: absolute;
      width: min(60vmin, 60%);
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
    }

    .poline-picker__circprev {
      width: 12vmin;
      height: 12vmin;
      background: conic-gradient(var(--prev));
      border-radius: 50%;
      position: absolute;
      top: 100%;
      left: 50%;
      z-index: 3;
      transition: transform 0.5s cubic-bezier(0.3, 0.7, 0, 1);
      box-shadow: 0 0 0 0.7vmin #fff;
      pointer-events: none;
      transform: translate(-50%, -50%) scale(0.4);
    }

    .picker {
      position: relative;
      width: 100%;
      aspect-ratio: 1;
      --s: .4;
      --l: .5;
      border-radius: 50%;
      background: radial-gradient(closest-side, #000, rgba(255, 255, 255, 0), #fff), conic-gradient(from 90deg, var(--grad));
    }

    svg {
      position: relative;
      z-index: 2;
      overflow: visible !important;
      width: 100%;
    
    }

    svg line.wheel__line {
      stroke: #202124;
      stroke-width: 0.25;
      stroke-dasharray: 0.5 0.5;
      pointer-events: none;
    }

    svg circle {
      stroke: #000;
      stroke-width: 0.25;
    }

    svg .wheel__point {
      pointer-events: none;
    }

    svg .wheel__anchor {
      pointer-events: all;
      cursor: grab;
    }

    svg line.wheel__satline {
      stroke-dasharray: 0 0;
      stroke-width: 1;
      stroke-linecap: round;
    }

    svg line.wheel__satline--bg {
      stroke: #fff;
      stroke-width: 1.5;
      stroke-dasharray: 0 0;
    }

    .wheel__huelabel {
      user-select: none;
      pointer-events: none;
      font-weight: normal;
      box-sizing: border-box;
      position: absolute;
      top: 50%;
      left: 50%;
      width: calc(100% + 16vmin);
      transform: translate(-50%, -50%) rotate(calc(var(--i, 0) * 360deg));
      font-size: 1.7vmin;
      padding: 0.2em 3em 0.2em 120.5%;
      z-index: 1;
      text-align: right;
      pointer-events: none;
      transition: font-size 0.3s cubic-bezier(.3,.7,0,1);
    }

    .picker:hover .wheel__huelabel {
      font-size: 1vmin;
    }

    .picker:hover .wheel__huelabel--active {
      font-size: 1.7vmin;
    }

    .wheel__huelabel::before,
    .wheel__huelabel::after {
      content: "";
      position: absolute;
      bottom: 50%;
      left: 91%;
      right: 6vmin;
      height: 1px;
      background: #202124;
      transform: translateY(50%);
    }

    .wheel__huelabel::after {
      height: 30%;
      aspect-ratio: 1;
      right: auto;
      left: 90%;
      background: hsl(calc(360 * var(--i, 0)), 100%, 70%);
      border-radius: 50%;
      border: 1px solid #fff;
      transform: translate(-50%, 50%) scale(1);
      transition: transform 0.2s ease-in-out;
    }

    .wheel__huelabel--active::after {
      transform: translate(-50%, 50%) scale(1.2);
    }

    label {
      display: block;
      margin: 1rem 0;
      font-size: .8rem;
    }
    label .t {
      display: block;
      margin: 0;
      font-size: 1rem;
    }
    select {
      margin-top: 1em;
      display: block;
      width: 100%;
      padding: 0;
      border: none;
      font: inherit;
      font-family: inherit;

      font-size: .8rem;
      text-decoration: underline;
    }
    .controls {
    }

    button {
      font-family: 'Aboreto', cursive;
      background-color: #202125;
      color: #fff;
    }

    .l-wrap {
      display: flex;
    }

    .l-menu {
      flex: 0 0 40%;
      width: 40%;
      box-sizing: border-box;
      padding: 0 8rem 0;
    }

    .l-demo {
      position: fixed;
      width: 60%;
      height: 100%;
      right: 0;
      border-left: 1px solid #e0e0e0;
    }
    
    .drawer {
      --preview-width: 2rem;
      position: fixed;
      top: 0;
      left: 0;
      bottom: 0;
      width: 30%;
      background: #202125;
      transform: translateX(calc(-100% + var(--preview-width)));
    }

    .drawer__preview {
      position: absolute;
      right: 0;
      bottom: 0;
      top: 0;
      width: var(--preview-width);

      background: linear-gradient(0deg, var(--prev));
    }
    .drawer__preview::before,
    .drawer__preview::after {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      bottom: 0;
      background: linear-gradient(0deg, var(--prev-smooth));
    }
    .drawer__preview::after {
      right: 0;
      width: 1rem;
      left: auto;
      display: none;
    }
    .drawer__preview::before {
      z-index: -1;
      transform: translateX(1rem) scaleY(1.1);
      filter: blur(15px);
      opacity: 0.5;
      right: 0;
    }
    .l-sec {
      min-height: 20vh;
      opacity: 1;
      transition: 400ms opacity linear;
    }
    .l-sec + .l-sec {
      margin-top: 10vh;
    }
    .l-sec--intro {
      padding-top: 32vh;
      display: flex;
      align-items: center;
    }
    .l-sec--intro + .l-sec {
    }
    .l-sec__inner {
      width: 100%;
    }
    .l-sec--active {
      opacity: 1;
      
    }
    .l-sec--active code {
    }
    .l-sec--active code::before {
      opacity: 1;
      transform: translateX(-1rem);
      transition: transform 400ms cubic-bezier(0.23, 1, 0.320, 1);
    }
    code {
      position: relative;
      display: block;
      font-family: 'Work Sans', sans-serif;
      font-size: .9rem;
      color: #000;
      background: #fff;
      padding: 1.5em 1.2em;
      border-radius: 0.2em;
      border: 1px solid #e0e0e0;
      background-color: #fff;
    }
    code::before {
      opacity: 1;
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(45deg, var(--prev-smooth));
      z-index: -1;
      opacity: 0;
      transform: translateX(0);
    }
  </style>
</head>

<body>
  <main class="l-wrap">
    <section class="l-menu">
      <div class="l-sec l-sec--intro">
        <div class="l-sec__inner" data-section="intro">
          <h1>Poline</h1>
          <p class="t-intro">
            "<strong class="t">poline</strong>" is an enigmatic color palette generator, that harnesses the mystical witchcraft of polar coordinates. Its
            methodology, defying conventional color science, is steeped in the esoteric knowledge of the early 20th century. This
            magical technology defies explanation, drawing lines between anchors to produce visually striking and otherworldly
            palettes. It is an indispensable tool for the modern generative sorcerer, and a delight for the eye.
          </p>
        </div>
      </div>
      <article class="l-sec">
        <div class="l-sec__inner" data-section="summoning">
          <h2>Summoning</h2>
          <p>
            When summoning a "<strong class="t">poline</strong>" without providing any arguments. 
            It will generate a palette with two random <strong>anchors</strong>. However, you can also
            provide a list of <strong>anchors</strong> to the function. The <strong>anchors</strong> are
            represented as a list of <strong>hsl</strong> values.
            <pre><code data-code></code></pre>
          </p>
        </div>
      </article>
      <article class="l-sec">
        <div class="l-sec__inner" data-section="points">
          <h2>Points</h2>
          <p>
            As demonstrated on the illustration, "<strong class="t">Poline</strong>"
            works by drawing lines between the <strong>anchors</strong>. The number of <strong>points</strong>
            determines the number of colors generated between each pair of anchors. 
            The more <strong>points</strong> you have, the more colors you will get.
          </p>
          <pre><code data-code></code></pre>
          <p>
            So the total amount of colors generated is <strong>points</strong> * <strong>pair of anchors</strong>.
          </p>
        </div>
      </article>
      <article class="l-sec">
        <div class="l-sec__inner" data-section="anchors">
          <h2>Anchors</h2>
          <p>
            The <strong>anchors</strong> are the points that the lines are drawn between. The <strong>anchors</strong> are
            represented as a list of <strong>hsl</strong> values. The <strong>hsl</strong> values are
            represented as a list of <strong>hue</strong>, <strong>saturation</strong> and <strong>lightness</strong>.
            The <strong>hue</strong>[0…360], the <strong>saturation</strong>[0…1] and the
            <strong>lightness</strong>[0…1].
          </p>
          <p>
            Either provide a list of <strong>anchors</strong> on initialization as in the examples above
            or let "<strong class="t">poline</strong>" generate a random palette for you. (by omitting the anchorColors argument)
          </p>
          <p>
            You can add anchors after initialization by calling the <strong>addAnchor</strong> method. 
            Either provide a list of <strong>hsl</strong> values or <strong>X,Y,Z</strong> coordinates.
          </p>
          <pre><code data-code></code></pre>
        </div>
      </article>
      <article class="l-sec">
        <div class="l-sec__inner" data-section="positionFunctions">
          <h2>Position Functions</h2>
          <p>
            The <strong>position functions</strong> are used to determine the position of the 
            <strong>points</strong> between the <strong>anchors</strong>. The <strong>position functions</strong> 
            can be the same for XYZ (positionFunction) or different for each axis (positionFunctionX, positionFunctionY, positionFunctionZ).
          </p>
          <p>
            They function a lot like an easing function and can be imported 'import {Poline, positionFunctions} from "poline";'
          </p>
          <pre><code data-code></code></pre>
        </div>
      </article>
      <article class="l-sec">
        <div class="l-sec__inner" data-section="closedLoop">
          <h2>Looping Palette</h2>
          <p>
            By default, the palette is not a closed loop. This means that the last color generated is not the same as the first color.
            If you want the palette to be a closed loop, you can set the <strong>closedLoop</strong> argument to true.
          </p>
          <pre><code data-code></code></pre>
        </div>
      </article>
      <div class="controls l-sec">
        <div class="l-sec__inner">
          <label>
            <span class="t">Steps</span>
            <input type="range" min="1" max="15" value="3" data-steps>
          </label>
          <label>
            <span class="t">Closed Loop<input type="checkbox" data-loop></span>
          </label>
          <label>
            <span><span class="t">Position fn X</span>(Hue / Light)</span>
            <select data-select="x">
            </select>
          </label>
          <label>
            <span><span class="t">Position fn Y</span>(Hue / Light)</span>
            <select data-select="y">
            </select>
          </label>
          <label>
            <span><span class="t">Position fn Z</span> (Saturation)</span>
            <select data-select="z">
            </select>
          </label>
          <label>
            <span class="t">Hue Shift</span>
            <input type="range" min="-10" max="10" value="0" step="0.1" data-hueshift>
          </label>
          <label>
            <span class="t">Color Model</span>
            <select data-models>
            </select>
          </label>
          <button data-randomize>Randomize</button>
        </div>
      </div>
    </section>
    <div class="l-demo">
      <div class="poline-picker">
        <div data-picker class="picker"></div>
        <div class="poline-picker__circprev"></div>
      </div>
    </div>
  </main>

  <div class="drawer">
    <h2>Export Colors</h2>
    <div class="drawer__preview">

    </div>
  </div>


  <script type="module">
    console.clear();
    import { formatHex } from 'https://cdn.skypack.dev/culori';
    
    import {
      Poline,
      positionFunctions,
      randomHSLPair,
    } from "./index.mjs";

    const svgscale = 100;
    const namespaceURI = 'http://www.w3.org/2000/svg';

    const hueBasedModels = [{
      key: 'okhsl',
      label: 'OKHSL',
      fn: (hsl) => {return {h : hsl[0], s: hsl[1], l: hsl[2]}},
    },
    {
      key: 'hsl',
      label: 'HSL',
      fn: (hsl) => { return { h: hsl[0], s: hsl[1], l: hsl[2] } },
    }
    , {
      key: 'jch',
      label: 'JCH',
      fn: (hsl) => { return { j: hsl[2] * 0.222, c: hsl[1] * 0.190, h: hsl[0] } },
    }, {
      key: 'oklch',
      label: 'OKLCH',
      fn: (hsl) => { return { l: hsl[2] * 0.999, c: hsl[1] * 0.322, h: hsl[0] } },
    }, {
      key: 'lch',
      label: 'LCH',
      fn: (hsl) => { return { l: hsl[2] * 100, c: hsl[1] * 51.484, h: hsl[0] } },
    }, {
        key: 'dlch',
        label: 'DLCH',
        fn: (hsl) => { return { l: hsl[2] * 100, c: hsl[1] * 51.484, h: hsl[0] } },
      }];

    let currentHueModel = 'hsl';
    let currentModelFn = hueBasedModels.find(m => m.key === currentHueModel).fn;

    const stepsToLabels = (steps = 360 / 10) => new Array(steps)
        .fill('')
        .map((_, i) => `
          <strong class="wheel__huelabel" data-huelabel="${i}" style="--i: ${i / steps}">${i * 10}</strong>`)
        .join('')

    const createCSSRainbowGradient = (steps = 360 / 10) => new Array(steps)
        .fill('')
        .map((_, i) => `hsl(${i / (steps - 1) * 360}, calc(var(--s) * 100%), calc(var(--l,0) * 100%))`)
        .join(',');

    const createSVG = (svgscale = 100) => {
      const $svg = document.createElementNS(
        namespaceURI, 'svg'
      );
      $svg.setAttribute('viewBox', `0 0 ${svgscale} ${svgscale}`);
      return $svg;
    }

    const colorArrToSteppedGradient = (colorsArr) => colorsArr.map(
      (c, i) => `${c} ${i / colorsArr.length * 100}% ${(i + 1) / colorsArr.length * 100}%`
    ).join();

    const $steps = document.querySelector('[data-steps]');
    const $selects = document.querySelectorAll('[data-select]');
    const $xSelect = document.querySelector('[data-select="x"]');
    const $ySelect = document.querySelector('[data-select="y"]');
    const $zSelect = document.querySelector('[data-select="z"]');
    const $models = document.querySelector('[data-models]');
    const $loop = document.querySelector('[data-loop]');
    const $hueshift = document.querySelector('[data-hueshift]');
    const $randomize = document.querySelector('[data-randomize]');

    $models.innerHTML = hueBasedModels
      .map(model => `<option ${model.key == currentHueModel ? 'selected="true"' : ""} value="${model.key}">${model.label}</option>`)
      .join('');
    
    $models.addEventListener('change', (e) => {
      currentHueModel = e.target.value;
      currentModelFn = hueBasedModels.find(m => m.key === currentHueModel).fn;
      updateSVG();
    });

    let fnx = 'sinusoidalPosition';
    let fny = 'quadraticPosition';
    let fnz = 'linearPosition';

    $selects.forEach($select => {
      Object.keys(positionFunctions).forEach(fn => {
        const $option = document.createElement('option');
        if ($select === $xSelect && fn === fnx) $option.selected = true;
        if ($select === $ySelect && fn === fny) $option.selected = true;
        if ($select === $zSelect && fn === fnz) $option.selected = true;
        $option.value = fn;
        $option.textContent = fn;
        $select.appendChild($option);
      });
    });

    let steps = parseInt($steps.value);

    let startHue = Math.random() * 360;

    let poline = new Poline({
      /*anchorColors: [
        [startHue, Math.random(), 0.8],
        [(startHue + 60 + Math.random() * 180) % 360, Math.random(), Math.random() * .2],
        [(startHue + 60 + Math.random() * 180) % 360, Math.random(), .8]
      ],*/
      numPoints: steps,
      positionFunctionX: positionFunctions[fnx],
      positionFunctionY: positionFunctions[fny],
      positionFunctionZ: positionFunctions[fnz],
      closedLoop: false,
    });

    const $picker = document.querySelector('[data-picker]');
    const hueSteps = 360 / 10;
    
    const $svg = createSVG(svgscale);
    $picker.innerHTML = stepsToLabels(hueSteps);
    const $huelabels = document.querySelectorAll('[data-huelabel]');
    $picker.appendChild($svg);
    
    $picker.style.setProperty('--grad', createCSSRainbowGradient(hueSteps));

    //const hue = Math.random() * 360;

    //poline.addAnchorPoint({color: [(startHue + 60 + Math.random() * 180) % 360, Math.random(), .8] });    
    //poline.addAnchorPoint({color: poline.anchorPoints[0].color});
    //console.log(poline);

    function updateSVG () {
      $huelabels.forEach(($huelabel, i) => {
        $huelabel.classList.remove('wheel__huelabel--active');
        // if the HUE label is within the range of the current anchor point
        poline.anchorPoints.forEach(anchor => {
          const currentHue = anchor.color[0];
          currentHue - hueSteps / 2 < i * 10 && currentHue + hueSteps / 2 > i * 10 && $huelabel.classList.add('wheel__huelabel--active');
        });
      });

      $svg.innerHTML = '';

      poline.anchorPoints.forEach(anchor => {
        const $circle = document.createElementNS(namespaceURI, 'circle');
        $circle.setAttribute('cx', anchor.x * svgscale);
        $circle.setAttribute('cy', anchor.y * svgscale);
        $circle.setAttribute('r', 2)
        //anchor.hslCSS
        $circle.classList.add('wheel__anchor');
        $circle.setAttribute('fill', '#fff');
        $svg.appendChild($circle);
      });

      poline.flattenedPoints.forEach((point, i) => {
        const $line = document.createElementNS(namespaceURI, 'line');
        $line.classList.add('wheel__line');
        $line.setAttribute('x1', point.x * svgscale);
        $line.setAttribute('y1', point.y * svgscale);
        const nextI = (i + 1) % poline.flattenedPoints.length;
        $line.setAttribute('x2', poline.flattenedPoints[nextI].x * svgscale);
        $line.setAttribute('y2', poline.flattenedPoints[nextI].y * svgscale);
        if (i !== poline.flattenedPoints.length - 1) {
          $svg.appendChild($line);
        }

        const $circle = document.createElementNS(namespaceURI, 'circle');
        $circle.setAttribute('cx', point.x * svgscale);
        $circle.setAttribute('cy', point.y * svgscale);
        $circle.setAttribute('r', .5 + point.color[1] * 1)
        $circle.classList.add('wheel__point');
        $circle.setAttribute('fill', formatHex({ mode: currentHueModel, ...currentModelFn(point.color) }) );
        $svg.appendChild($circle);

        /*
        // create a vertical line with a height representing the saturation
        const $vline = document.createElementNS(namespaceURI, 'line');
        const $vlineBG = document.createElementNS(namespaceURI, 'line');
        $vlineBG.setAttribute('x1', point.x * svgscale);
        $vline.setAttribute('x1', point.x * svgscale);

        $vline.setAttribute('y1', point.y * svgscale);
        $vlineBG.setAttribute('y1', point.y * svgscale);

        $vline.setAttribute('x2', point.x * svgscale);
        $vlineBG.setAttribute('x2', point.x * svgscale);

        $vline.setAttribute('y2', point.y * svgscale - point.color[1] * 7);
        $vlineBG.setAttribute('y2', point.y * svgscale - point.color[1] * 7);
        $vline.setAttribute('stroke', point.hslCSS);
        $vline.classList.add('wheel__satline');
        $vlineBG.setAttribute('stroke', '#fff');
        $vlineBG.classList.add('wheel__satline', 'wheel__satline--bg');
        $svg.appendChild($vlineBG);
        $svg.appendChild($vline);
        */
      });
      
      let cssColors = [...poline.colorsCSS];
      let colors = [...poline.colors].map(c => formatHex({ mode: currentHueModel, ...currentModelFn(c) }));
      //colors = [...poline.colors].map(c => formatCss({ mode: 'p3', ...currentModelFn(c) }));
      document.documentElement.style.setProperty(
        '--prev',
        colorArrToSteppedGradient(colors)
      )

      document.documentElement.style.setProperty(
        '--prev-smooth',
        colors.join(',')
      )

    }

    updateSVG();

    $loop.addEventListener('input', () => {
      poline.closedLoop = $loop.checked;
      updateSVG();
    });

    $steps.addEventListener('input', () => {
      steps = parseInt($steps.value);
      poline.numPoints = steps;

      updateSVG();
    });

    $xSelect.addEventListener('input', () => {
      fnx = $xSelect.value;
      poline.positionFunctionX = positionFunctions[fnx];
      updateSVG();
    });

    $ySelect.addEventListener('input', () => {
      fny = $ySelect.value;
      poline.positionFunctionY = positionFunctions[fny];
      updateSVG();
    });

    $zSelect.addEventListener('input', () => {
      fnz = $zSelect.value;
      poline.positionFunctionZ = positionFunctions[fnz];
      updateSVG();
    });

    $randomize.addEventListener('click', () => {
      poline.anchorPoints.forEach(anchor => {
        anchor.hsl = [
          (anchor.color[0] + (-90 + Math.random() * 90)) % 360,
          Math.random(),
          anchor.color[2] + (-.05 + Math.random() * .1)
        ];
      });
      poline.updatePointPairs();
      updateSVG();
    });

    let currentPoint = null;
    let lastSelectedPoint = null;
    let lastX = 0;
    let lastY = 0;

    $picker.addEventListener('pointerdown', (e) => {
      const x = lastX = e.offsetX / $picker.offsetWidth;
      const y = lastY = e.offsetY / $picker.offsetHeight;

      if (!currentPoint) {
        currentPoint = poline.getClosestAnchorPoint([x, y, null], .1);
        lastSelectedPoint = currentPoint;
      } else {
        currentPoint = null;
      }
    });

    $picker.addEventListener('pointermove', (e) => {
      const x = lastX = e.offsetX / $picker.offsetWidth;
      const y = lastY = e.offsetY / $picker.offsetHeight;

      if (currentPoint) {
        currentPoint.position = [x, y, currentPoint.z];
        poline.updatePointPairs();
        updateSVG();
      } 
    });

  
  /*
  setInterval(() => {
    poline.anchorPoints[0].hsl = [
      (poline.anchorPoints[0].color[0] + 1) % 360,
      poline.anchorPoints[0].color[1],
      poline.anchorPoints[0].color[2]
    ];

    poline.anchorPoints[2].hsl = [
      (poline.anchorPoints[2].color[0] - 1) % 360,
      poline.anchorPoints[2].color[1],
      poline.anchorPoints[2].color[2]
    ];

    poline.updatePointPairs();
    updateSVG();
  }, 16.66);
  */
  


  $picker.addEventListener('pointerup', (e) => {
    currentPoint = null;
  });

  // listen for keypresses
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Delete' || e.key === 'Backspace') {
      if (!lastSelectedPoint) return;
      poline.removeAnchorPoint(lastSelectedPoint);
      updateSVG();
    }

    if (e.key === 'p') {
      lastSelectedPoint = poline.addAnchorPoint({x: lastX, y: lastY, z: lastY});
      updateSVG();
    }
  });

  $hueshift.addEventListener('input', (e) => {
    poline.shiftHue(parseFloat(e.target.value));

    updateSVG();
  });


  let exStartHue = Math.random() * 360;

  // scripts per section
  const stroyScripts = [{
    section: 'intro',
    fn: () => {
      console.log('intro');
      poline = new Poline({
        numPoints: steps,
      });
      updateSVG();
    },
  },
  {
    section: 'summoning',
    fn: (section) => {
      console.log('summoning');
      exStartHue = Math.random() * 360;
      poline = new Poline({
        anchorColors: [
          [exStartHue, Math.random(), 0.8],
          [(exStartHue + 60 + Math.random() * 180) % 360, Math.random(), Math.random() * .2],
          /*[(exStartHue + 60 + Math.random() * 180) % 360, Math.random(), .8]*/
        ],
      });
      updateSVG();
      const $code = section.target.querySelector('[data-code]');
      $code.innerHTML = `new Poline({
  anchorColors: [
    [${
      Math.round(poline.anchorPoints[0].color[0])
    }, ${
      poline.anchorPoints[0].color[1].toFixed(2)
    }, ${
      poline.anchorPoints[0].color[2].toFixed(2)
    }],
    [${
      Math.round(poline.anchorPoints[1].color[0])
    }, ${
      poline.anchorPoints[1].color[1].toFixed(2)
    }, ${
      poline.anchorPoints[1].color[2].toFixed(2)
    }],
  ],
});`;
    },
  },
  {
    section: 'points',
    fn: (section) => {
      console.log('points');
      poline.numPoints = 10;
      updateSVG();
      const $code = section.target.querySelector('[data-code]');
      $code.innerHTML = `new Poline({
  numPoints: 10,
});`;
    },
  },
  {
    section: 'anchors',
    fn: (section) => {
      console.log('anchors');
      if (poline.anchorPoints.length > 3) {
        poline.anchorPoints.forEach((anchor, i) => {
          if (i > 1) poline.removeAnchorPoint(anchor);
        });
      }
      poline.addAnchorPoint({color: [(exStartHue + 60 + Math.random() * 180) % 360, Math.random(), .8] });
      const $code = section.target.querySelector('[data-code]');
      $code.innerHTML = `poline.addAnchorPoint({color: [${
        Math.round(poline.anchorPoints[poline.anchorPoints.length - 1].color[0])
      }, ${
        poline.anchorPoints[poline.anchorPoints.length - 1].color[1].toFixed(2)
      }, ${
        poline.anchorPoints[poline.anchorPoints.length - 1].color[2].toFixed(2)
      }]});`;
      updateSVG();
    }
  },
  {
    section: 'positionFunctions',
    fn: (section) => {
      console.log('Position Functions');
      if (poline.anchorPoints.length > 3) {
        poline.anchorPoints.forEach((anchor, i) => {
          if (i > 1) poline.removeAnchorPoint(anchor);
        });
      }
      poline.closedLoop = false;
      poline.positionFunctionX = positionFunctions[fnx];
      poline.positionFunctionY = positionFunctions[fny];
      poline.positionFunctionZ = positionFunctions[fnz];
      poline.updatePointPairs();
      const $code = section.target.querySelector('[data-code]');
      $code.innerHTML = `new Poline({
  positionFunctionX: positionFunctions.${poline.positionFunctionX.name},
  positionFunctionY: positionFunctions.${poline.positionFunctionY.name},
  positionFunctionZ: positionFunctions.${poline.positionFunctionZ.name},
});`;
      updateSVG();
    },
  },
  {
    section: 'closedLoop',
    fn: (section) => {
      console.log('closedLoop');
      poline.closedLoop = true;
      poline.updatePointPairs();
      const $code = section.target.querySelector('[data-code]');
      $code.innerHTML = `new Poline({
  closedLoop: true,
});`;
  updateSVG()
    },
  },
];
  
  // create an intersection onserver for all the `data-section`s
  const sections = [...document.querySelectorAll('[data-section]')];
  const observer = new IntersectionObserver((entries) => {
    entries.forEach(entry => {
      if (entry.isIntersecting) {
        // find the script for this section in stroyScripts
        const script = stroyScripts.find(s => s.section === entry.target.dataset.section);
        if (script) {
          script.fn(entry);
        }
        // add .l-sec--active to the section when it's in view
        // and remove it on all other sections
        sections.forEach(section => {
          if (section === entry.target) {
            section.parentElement.classList.add('l-sec--active');
          } else {
            section.parentElement.classList.remove('l-sec--active');
          }
        });
        
      }
    });
  }, {
    rootMargin: '0px 0px -50% 0px'
  });

  sections.forEach(section => {
    observer.observe(section);
  });
  </script>
</body>

</html>