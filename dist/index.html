<!DOCTYPE html>

<html lang="en">

<head>
  <meta charset="utf-8" />
  <!-- Primary Meta Tags -->
  <title>Poline</title>
  <!-- Primary Meta Tags -->
  <title>Poline — esoteric color palette generator</title>
  <meta name="title" content="Poline —  esoteric color palette generator">
  <meta name="description"
    content="poline is lightweight, dependency free and fast JavaScript function written in TypeScript. It draws lines between anchors over polar coordinates to generate pleasing color palettes.">

  <!-- Open Graph / Facebook -->
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://meodai.github.io/poline/">
  <meta property="og:title" content="Poline —  esoteric color palette generator">
  <meta property="og:description"
    content="poline is lightweight, dependency free and fast JavaScript function written in TypeScript. It draws lines between anchors over polar coordinates to generate pleasing color palettes.">
  <meta property="og:image" content="https://meodai.github.io/poline/socialfb.png">

  <!-- Twitter -->
  <meta property="twitter:card" content="summary_large_image">
  <meta property="twitter:url" content="https://meodai.github.io/poline/">
  <meta property="twitter:title" content="Poline —  esoteric color palette generator">
  <meta property="twitter:description"
    content="poline is lightweight, dependency free and fast JavaScript function written in TypeScript. It draws lines between anchors over polar coordinates to generate pleasing color palettes.">
  <meta property="twitter:image" content="https://meodai.github.io/poline/socialfb.png">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Aboreto&display=swap" rel="stylesheet">

  <style>
    :root {
      font-family: "Inter", sans-serif;
      background: #fff;
      color: #202124;

      font-family: 'Aboreto', cursive;
    }

    h1 {
      position: absolute;
      top: 0;
      left: 50%;
      font-size: 5rem;
      text-align: center;
      margin: 0;
      padding: 0;
      font-weight: normal;
      transform: translate(-50%, 0);
      letter-spacing: -0.05em;
    }

    .poline-picker {
      position: relative;
      width: 60vmin;
      margin: 12rem auto 0;
    }
    .poline-picker__preview {
      height: 2vmin;
      margin: 15vmin auto 0;
      width: 80%;
      background: linear-gradient(90deg, var(--prev));
      transition: transform 0.5s cubic-bezier(0.3, 0.7, 0, 1);
    }
    .poline-picker__preview:hover {
      transform: scaleY(4);
    }
    .poline-picker__circprev {
      width: 12vmin;
      height: 12vmin;
      background: conic-gradient(var(--prev));
      border-radius: 50%;
      position: absolute;
      top: calc(100% - 11vmin);
      left: 50%;
      z-index: 3;
      transform: translate(-50%, -100%) scale(0.4);
      transition: transform 0.5s cubic-bezier(0.3, 0.7, 0, 1);
      box-shadow: 0 0 0 0.5vmin #fff;
    }
    .poline-picker__circprev:hover {
      transform: translate(-50%, -100%) scale(1);
    }
    .picker {
      position: relative;
      width: 100%;
      aspect-ratio: 1;
      --s: .4;
      --l: .5;
      border-radius: 50%;
      background: radial-gradient(closest-side, #000, rgba(255, 255, 255, 0), #fff), conic-gradient(from 90deg, var(--grad));
    }

    svg {
      position: relative;
      z-index: 2;
      overflow: visible !important;
      width: 100%;
    
    }

    svg line.wheel__line {
      stroke: #202124;
      stroke-width: 0.25;
      stroke-dasharray: 0.5 0.5;
      pointer-events: none;
    }

    svg circle {
      stroke: #000;
      stroke-width: 0.25;
    }

    svg .wheel__point {
      pointer-events: none;
    }

    svg .wheel__anchor {
      pointer-events: all;
      cursor: grab;
    }

    svg line.wheel__satline {
      stroke-dasharray: 0 0;
      stroke-width: 1;
      stroke-linecap: round;
    }

    svg line.wheel__satline--bg {
      stroke: #fff;
      stroke-width: 1.5;
      stroke-dasharray: 0 0;
    }

    .wheel__huelabel {
      -webkit-user-select: none;
        -moz-user-select: none;
          -ms-user-select: none;
              user-select: none;
      pointer-events: none;
      font-weight: normal;
      box-sizing: border-box;
      position: absolute;
      top: 50%;
      left: 50%;
      width: calc(100% + 16vmin);
      transform: translate(-50%, -50%) rotate(calc(var(--i, 0) * 360deg));
      font-size: 1vmin;
      padding: 0.2em 3em 0.2em 120.5%;
      z-index: 1;
      text-align: right;
      pointer-events: none;
      transition: font-size 0.3s cubic-bezier(.3,.7,0,1);
    }

    .wheel__huelabel--active {
      font-size: 1.7vmin;
    }

    .wheel__huelabel::before,
    .wheel__huelabel::after {
      content: "";
      position: absolute;
      bottom: 50%;
      left: 91%;
      right: 6vmin;
      height: 1px;
      background: #202124;
      transform: translateY(50%);
    }

    .wheel__huelabel::after {
      height: 30%;
      aspect-ratio: 1;
      right: auto;
      left: 90%;
      background: hsl(calc(360 * var(--i, 0)), 100%, 70%);
      border-radius: 50%;
      border: 1px solid #fff;
      transform: translate(-50%, 50%) scale(1);
      transition: transform 0.2s ease-in-out;
    }

    .wheel__huelabel--active::after {
      transform: translate(-50%, 50%) scale(1.2);
    }

    label {
      display: block;
      margin: 1rem 0;
    }
    label span {
      display: block;
      margin-bottom: 0.5rem;
    }
    select {
      display: block;
      width: 100%;
      font-size: 1rem;
      padding: 0;
      border: none;
      font: inherit;
      font-family: monospace;
      text-decoration: underline;
    }
    .controls {
      position: absolute;
      bottom: 5vmin;
      left: 0;
      padding: 1rem;
    }
    h2 {
      position: absolute;
      top: 0;
      left: 0;
      font-size: 2rem;
      text-align: center;
      margin: 0;
      padding: 0;
      font-weight: normal;
      transform: translate(0, 0);
      letter-spacing: -0.05em;
      display: none;
    }
    .t-intro {
      margin: 10vmin auto;
      max-width: 40vmin;
      text-align: center;
    }
  </style>
</head>

<body>
  <h1>Poline</h1>
  <h2>極地線</h2>

  <div class="poline-picker">
    <div data-picker class="picker"></div>
    <div class="poline-picker__preview"></div>
    <div class="poline-picker__circprev"></div>
  </div>

  <p class="t-intro">
    "Poline" is an esoteric color palette generator that is not based 
    on color science, but rather designed to be visually pleasing. 
    It draws lines between anchors over polar coordinates.
  </p>

  <div class="controls">

    <label>
      <span>Color Model</span>
      <select data-models>
      </select>
    </label>
    <label>
      <span>Steps</span>
      <input type="range" min="3" max="15" value="3" data-steps>
    </label>
    <label>
      <span>Position fn X</span>
      <select data-select="x">
      </select>
    </label><label>
      <span>Position fn Y</span>
      <select data-select="y">
      </select>
    </label><label>
      <span>Position fn Z</span>
      <select data-select="z">
      </select>
    </label>
  </div>
  <script type="module">
    console.clear();
    import { formatHex } from 'https://cdn.skypack.dev/culori';
    
    import {
      Poline,
      positionFunctions,
      randomHSLPair,
    } from "./index.mjs";


    const scale = 100;
    const namespaceURI = 'http://www.w3.org/2000/svg';

    const hueBasedModels = [{
      key: 'okhsl',
      label: 'OKHSL',
      fn: (hsl) => {return {h : hsl[0], s: hsl[1], l: hsl[2]}},
    },
    {
      key: 'hsl',
      label: 'HSL',
      fn: (hsl) => { return { h: hsl[0], s: hsl[1], l: hsl[2] } },
    }
    , {
      key: 'jch',
      label: 'JCH',
      fn: (hsl) => { return { j: hsl[2] * 0.222, c: hsl[1] * 0.190, h: hsl[0] } },
    }, {
      key: 'oklch',
      label: 'OKLCH',
      fn: (hsl) => { return { l: hsl[2] * 0.999, c: hsl[1] * 0.322, h: hsl[0] } },
    }, {
      key: 'lch',
      label: 'LCH',
      fn: (hsl) => { return { l: hsl[2] * 100, c: hsl[1] * 51.484, h: hsl[0] } },
    }, {
        key: 'dlch',
        label: 'DLCH',
        fn: (hsl) => { return { l: hsl[2] * 100, c: hsl[1] * 51.484, h: hsl[0] } },
      }];

    let currentHueModel = 'hsl';
    let currentModelFn = hueBasedModels.find(m => m.key === currentHueModel).fn;

    const stepsToLabels = (steps = 360 / 10) => new Array(steps)
        .fill('')
        .map((_, i) => `
          <strong class="wheel__huelabel" data-huelabel="${i}" style="--i: ${i / steps}">${i * 10}</strong>`)
        .join('')

    const createCSSRainbowGradient = (steps = 360 / 10) => new Array(steps)
        .fill('')
        .map((_, i) => `hsl(${i / (steps - 1) * 360}, calc(var(--s) * 100%), calc(var(--l,0) * 100%))`)
        .join(',');

    const createSVG = (scale = 100) => {
      const $svg = document.createElementNS(
        namespaceURI, 'svg'
      );
      $svg.setAttribute('viewBox', `0 0 ${scale} ${scale}`);
      return $svg;
    }

    const colorArrToSteppedGradient = (colorsArr) => colorsArr.map(
      (c, i) => `${c} ${i / colorsArr.length * 100}% ${(i + 1) / colorsArr.length * 100}%`
    ).join();

    
    const $steps = document.querySelector('[data-steps]');
    const $selects = document.querySelectorAll('[data-select]');
    const $xSelect = document.querySelector('[data-select="x"]');
    const $ySelect = document.querySelector('[data-select="y"]');
    const $zSelect = document.querySelector('[data-select="z"]');
    const $models = document.querySelector('[data-models]');
    $models.innerHTML = hueBasedModels
      .map(model => `<option ${model.key == currentHueModel ? 'selected="true"' : ""} value="${model.key}">${model.label}</option>`)
      .join('');
    
    $models.addEventListener('change', (e) => {
      currentHueModel = e.target.value;
      currentModelFn = hueBasedModels.find(m => m.key === currentHueModel).fn;
      updateSVG();
    });

    let fnx = 'sinusoidalPosition';
    let fny = 'quadraticPosition';
    let fnz = 'linearPosition';

    $selects.forEach($select => {
      Object.keys(positionFunctions).forEach(fn => {
        const $option = document.createElement('option');
        if ($select === $xSelect && fn === fnx) $option.selected = true;
        if ($select === $ySelect && fn === fny) $option.selected = true;
        if ($select === $zSelect && fn === fnz) $option.selected = true;
        $option.value = fn;
        $option.textContent = fn;
        $select.appendChild($option);
      });
    });

    let steps = parseInt($steps.value);

    let poline = new Poline(
      randomHSLPair(),
      steps,
      positionFunctions[fnx],
      positionFunctions[fny],
      positionFunctions[fnz],
    );

    const $picker = document.querySelector('[data-picker]');
    const hueSteps = 360 / 10;
    
    const $svg = createSVG(scale);
    $picker.innerHTML = stepsToLabels(hueSteps);
    const $huelabels = document.querySelectorAll('[data-huelabel]');
    $picker.appendChild($svg);
    
    $picker.style.setProperty('--grad', createCSSRainbowGradient(hueSteps));

    const hue = Math.random() * 360;

    poline.addAnchorPoint({color: [hue, Math.random(), .6 + Math.random() * .3]});    
    poline.addAnchorPoint({color: poline.anchorPoints[0].color});
    //console.log(poline);

    function updateSVG () {
      $huelabels.forEach(($huelabel, i) => {
        $huelabel.classList.remove('wheel__huelabel--active');
        // if the HUE label is within the range of the current anchor point
        poline.anchorPoints.forEach(anchor => {
          const currentHue = anchor.color[0];
          currentHue - hueSteps / 2 < i * 10 && currentHue + hueSteps / 2 > i * 10 && $huelabel.classList.add('wheel__huelabel--active');
          
          
        });
      });

      $svg.innerHTML = '';

      poline.anchorPoints.forEach(anchor => {
        const $circle = document.createElementNS(namespaceURI, 'circle');
        $circle.setAttribute('cx', anchor.x * scale);
        $circle.setAttribute('cy', anchor.y * scale);
        $circle.setAttribute('r', 2)
        //anchor.hslCSS
        $circle.classList.add('wheel__anchor');
        $circle.setAttribute('fill', '#fff');
        $svg.appendChild($circle);
      });

      poline.flattenedPoints.forEach((point, i) => {
        const $line = document.createElementNS(namespaceURI, 'line');
        $line.classList.add('wheel__line');
        $line.setAttribute('x1', point.x * scale);
        $line.setAttribute('y1', point.y * scale);
        const nextI = (i + 1) % poline.flattenedPoints.length;
        $line.setAttribute('x2', poline.flattenedPoints[nextI].x * scale);
        $line.setAttribute('y2', poline.flattenedPoints[nextI].y * scale);
        if (i !== poline.flattenedPoints.length - 1) {
          $svg.appendChild($line);
        }

        const $circle = document.createElementNS(namespaceURI, 'circle');
        $circle.setAttribute('cx', point.x * scale);
        $circle.setAttribute('cy', point.y * scale);
        $circle.setAttribute('r', .5 + point.color[1] * 1)
        $circle.classList.add('wheel__point');
        $circle.setAttribute('fill', point.hslCSS);
        $svg.appendChild($circle);

        /*
        // create a vertical line with a height representing the saturation
        const $vline = document.createElementNS(namespaceURI, 'line');
        const $vlineBG = document.createElementNS(namespaceURI, 'line');
        $vlineBG.setAttribute('x1', point.x * scale);
        $vline.setAttribute('x1', point.x * scale);

        $vline.setAttribute('y1', point.y * scale);
        $vlineBG.setAttribute('y1', point.y * scale);

        $vline.setAttribute('x2', point.x * scale);
        $vlineBG.setAttribute('x2', point.x * scale);

        $vline.setAttribute('y2', point.y * scale - point.color[1] * 7);
        $vlineBG.setAttribute('y2', point.y * scale - point.color[1] * 7);
        $vline.setAttribute('stroke', point.hslCSS);
        $vline.classList.add('wheel__satline');
        $vlineBG.setAttribute('stroke', '#fff');
        $vlineBG.classList.add('wheel__satline', 'wheel__satline--bg');
        $svg.appendChild($vlineBG);
        $svg.appendChild($vline);
        */
      });
      
      let cssColors = [...poline.colorsCSS];
      cssColors.pop();
      let colors = [...poline.colors].map(c => formatHex({ mode: currentHueModel, ...currentModelFn(c) }));
      //colors = [...poline.colors].map(c => formatCss({ mode: 'p3', ...currentModelFn(c) }));
      document.documentElement.style.setProperty(
        '--prev',
        colorArrToSteppedGradient(colors)
      )

    }

    updateSVG();


    $steps.addEventListener('input', () => {
      steps = parseInt($steps.value);
      poline.numPoints = steps;
      poline.updatePointPairs();

      updateSVG();
    });

    $xSelect.addEventListener('input', () => {
      fnx = $xSelect.value;
      poline.positionFunction = positionFunctions[fnx];
      poline.updatePointPairs();
      updateSVG();
    });

    $ySelect.addEventListener('input', () => {
      fny = $ySelect.value;
      poline.positionFunctionY = positionFunctions[fny];
      poline.updatePointPairs();
      updateSVG();
    });

    $zSelect.addEventListener('input', () => {
      fnz = $zSelect.value;
      poline.positionFunctionZ = positionFunctions[fnz];
      poline.updatePointPairs();
      updateSVG();
    });

    let currentPoint = null;
    let lastSelectedPoint = null;
    let lastX = 0;
    let lastY = 0;


    $picker.addEventListener('pointerdown', (e) => {
      const x = lastX = e.offsetX / $picker.offsetWidth;
      const y = lastY = e.offsetY / $picker.offsetHeight;

      if (!currentPoint) {
        currentPoint = poline.getClosestAnchorPoint([x, null, y], .1);
        lastSelectedPoint = currentPoint;
      }

    });

    $picker.addEventListener('pointermove', (e) => {
      const x = lastX = e.offsetX / $picker.offsetWidth;
      const y = lastY = e.offsetY / $picker.offsetHeight;

      if (currentPoint) {
        currentPoint.x = x;
        currentPoint.y = y;
        currentPoint.positionOrColor = {
          x,
          y,
          z: currentPoint.z,
        };

        poline.updatePointPairs();
        updateSVG();
      } 
      
      /*else if (e.buttons === 1) {
        // move all points relative to the mouse position

        poline.anchorPoints.forEach(point => {
          point.positionOrColor = {
            x: (x - point.x),
            y: (y - point.y),
            z: point.z,
          };
        });
        poline.updatePointPairs();
        updateSVG();
      }*/
    });



  $picker.addEventListener('pointerup', (e) => {
    currentPoint = null;
  });

  // listen for keypresses
  document.addEventListener('keydown', (e) => {
    if (e.key === 'Delete' || e.key === 'Backspace') {
      if (!lastSelectedPoint) return;
      poline.removeAnchorPoint(lastSelectedPoint);
      updateSVG();
    }

    if (e.key === ' ') {
      lastSelectedPoint = poline.addAnchorPoint({x: lastX, y: lastY, z: lastY});
      updateSVG();
    }
  });

  </script>
</body>

</html>